[
  {
    "objectID": "posts/bayes-regression/bayesian_regression_mcmc_and_svi.html",
    "href": "posts/bayes-regression/bayesian_regression_mcmc_and_svi.html",
    "title": "Bayesian Regression Using Pyro",
    "section": "",
    "text": "In this tutorial, we will explore how to do bayesian regression in Pyro, using a simple example adapted from Statistical Rethinking [1]. In particular, we would like to explore the following:\n\nWrite a simple model using the sample Pyro primitive.\nRun inference using MCMC in Pyro, in particular, using the No U-Turn Sampler (NUTS) to get a posterior distribution over our regression parameters of interest. We also show an example of inference using Pyro’s SVI.\nLearn about inference utilities such as Predictive and log_likelihood.\nLearn how we can use effect-handlers in Pyro to generate execution traces from the model, condition on sample statements, etc., and use this to implement various utilities that will be useful for MCMC. e.g. computing model log likelihood, generating empirical distribution over the posterior predictive, etc.\n\n\n\n\nDataset\nRegression Model to Predict Divorce Rate\n\nModel-1: Predictor-Marriage Rate\n\nPosterior Distribution over the Regression Parameters\nPrior Predictive Distribution\nPosterior Predictive Distribution\nPredictive Utility With Effect Handlers\nModel Predictive Density\nRegression with Pyro’s Stochastic Variational Inference (SVI)\n\nModel-2: Predictor-Median Age of Marriage\nModel-3: Predictor-Marriage Rate and Median Age of Marriage\nDivorce Rate Residuals by State\n\nRegression Model with Measurement Error\n\nEffect of Incorporating Measurement Noise on Residuals\n\nReferences\n\n\nimport os\n\nfrom IPython.display import set_matplotlib_formats\nimport torch\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nfrom torch import logsumexp\n\nimport pyro\nimport pyro.distributions as dist\nimport pyro.poutine as poutine\nimport pyro.optim as optim\nfrom pyro.infer import HMC, NUTS, MCMC\nimport pyro.ops.stats as stats\n\nplt.style.use(\"bmh\")\n\nassert pyro.__version__.startswith('1.8.0')\nsmoke_test = ('CI' in os.environ)\npyro.set_rng_seed(1)\n\n\n\n\nFor this example, we will use the WaffleDivorce dataset from Chapter 05, Statistical Rethinking [1]. The dataset contains divorce rates in each of the 50 states in the USA, along with predictors such as population, median age of marriage, whether it is a Southern state and, curiously, number of Waffle Houses.\n\nDATASET_URL = \"https://raw.githubusercontent.com/rmcelreath/rethinking/master/data/WaffleDivorce.csv\"\ndset = pd.read_csv(DATASET_URL, sep=\";\")\ndset.head()\n\n\n\n\n\n  \n    \n      \n      Location\n      Loc\n      Population\n      MedianAgeMarriage\n      Marriage\n      Marriage SE\n      Divorce\n      Divorce SE\n      WaffleHouses\n      South\n      Slaves1860\n      Population1860\n      PropSlaves1860\n    \n  \n  \n    \n      0\n      Alabama\n      AL\n      4.78\n      25.3\n      20.2\n      1.27\n      12.7\n      0.79\n      128\n      1\n      435080\n      964201\n      0.45\n    \n    \n      1\n      Alaska\n      AK\n      0.71\n      25.2\n      26.0\n      2.93\n      12.5\n      2.05\n      0\n      0\n      0\n      0\n      0.00\n    \n    \n      2\n      Arizona\n      AZ\n      6.33\n      25.8\n      20.3\n      0.98\n      10.8\n      0.74\n      18\n      0\n      0\n      0\n      0.00\n    \n    \n      3\n      Arkansas\n      AR\n      2.92\n      24.3\n      26.4\n      1.70\n      13.5\n      1.22\n      41\n      1\n      111115\n      435450\n      0.26\n    \n    \n      4\n      California\n      CA\n      37.25\n      26.8\n      19.1\n      0.39\n      8.0\n      0.24\n      0\n      0\n      0\n      379994\n      0.00\n    \n  \n\n\n\n\nLet us plot the pair-wise relationship amongst the main variables in the dataset, using seaborn.pairplot.\n\nvars = [\n    \"Population\",\n    \"MedianAgeMarriage\",\n    \"Marriage\",\n    \"WaffleHouses\",\n    \"South\",\n    \"Divorce\",\n]\nsns.pairplot(dset, x_vars=vars, y_vars=vars, palette=\"husl\");\n\n\n\n\nFrom the plots above, we can clearly observe that there is a relationship between divorce rates and marriage rates in a state (as might be expected), and also between divorce rates and median age of marriage.\nThere is also a weak relationship between number of Waffle Houses and divorce rates, which is not obvious from the plot above, but will be clearer if we regress Divorce against WaffleHouse and plot the results.\n\nsns.regplot(x=\"WaffleHouses\", y=\"Divorce\", data=dset);\n\n\n\n\nThis is an example of a spurious association. We do not expect the number of Waffle Houses in a state to affect the divorce rate, but it is likely correlated with other factors that have an effect on the divorce rate. We will not delve into this spurious association in this tutorial, but the interested reader is encouraged to read Chapters 5 and 6 of [1] which explores the problem of causal association in the presence of multiple predictors.\nFor simplicity, we will primarily focus on marriage rate and the median age of marriage as our predictors for divorce rate throughout the remaining tutorial.\n\n\n\nLet us now write a regression model in Pyro to predict the divorce rate as a linear function of marriage rate and median age of marriage in each of the states.\nFirst, note that our predictor variables have somewhat different scales. It is a good practice to standardize our predictors and response variables to mean 0 and standard deviation 1, which should result in faster inference.\n\nstandardize = lambda x: (x - x.mean()) / x.std()\n\ndset[\"AgeScaled\"] = dset.MedianAgeMarriage.pipe(standardize)\ndset[\"MarriageScaled\"] = dset.Marriage.pipe(standardize)\ndset[\"DivorceScaled\"] = dset.Divorce.pipe(standardize)\n\nWe write the Pyro model as follows. While the code should largely be self-explanatory, take note of the following:\n\nIn Pyro, model code is any Python callable which can optionally accept additional arguments and keywords. For HMC which we will be using for this tutorial, these arguments and keywords remain static during inference, but we can reuse the same model to generate predictions on new data.\nIn addition to regular Python statements, the model code also contains primitives like sample. These primitives can be interpreted with various side-effects using effect handlers. For more on effect handlers, refer to [3], [4]. For now, just remember that a sample statement makes this a stochastic function that samples some latent parameters from a prior distribution. Our goal is to infer the posterior distribution of these parameters conditioned on observed data.\nThe reason why we have kept our predictors as optional keyword arguments is to be able to reuse the same model as we vary the set of predictors. Likewise, the reason why the response variable is optional is that we would like to reuse this model to sample from the posterior predictive distribution. See the section on plotting the posterior predictive distribution, as an example.\n\n\ndef model(marriage=None, age=None, divorce=None):\n    a = pyro.sample(\"a\", dist.Normal(0.0, 0.2))\n    M, A = 0.0, 0.0\n    nums = 0\n    if age is not None:\n        nums = age.shape[0]\n        bA = pyro.sample(\"bA\", dist.Normal(0.0, 0.5))\n        A = bA * age\n    if marriage is not None:\n        nums = marriage.shape[0]\n        bM = pyro.sample(\"bM\", dist.Normal(0.0, 0.5))\n        M = bM * marriage\n    sigma = pyro.sample(\"sigma\", dist.Exponential(1.0))\n    mu = a + M + A\n    # pyro.sample(\"obs\", dist.Normal(mu, sigma), obs=divorce)\n    with pyro.plate(\"data\"):\n        pyro.sample(\"obs\", dist.Normal(mu, sigma), obs=divorce)\n\n\n\nWe first try to model the divorce rate as depending on a single variable, marriage rate. As mentioned above, we can use the same model code as earlier, but only pass values for marriage and divorce keyword arguments. We will use the No U-Turn Sampler (see [5] for more details on the NUTS algorithm) to run inference on this simple model.\nThe Hamiltonian Monte Carlo (or, the NUTS) implementation in Pyro takes in a potential energy function. This is the negative log joint density for the model. Therefore, for our model description above, we need to construct a function which given the parameter values returns the potential energy (or negative log joint density). Additionally, the verlet integrator in HMC (or, NUTS) returns sample values simulated using Hamiltonian dynamics in the unconstrained space. As such, continuous variables with bounded support need to be transformed into unconstrained space using bijective transforms. We also need to transform these samples back to their constrained support before returning these values to the user. Thankfully, this is handled on the backend for us, within a convenience class for doing MCMC inference that has the following methods:\n\nrun(...): runs warmup, adapts steps size and mass matrix, and does sampling using the sample from the warmup phase.\nsummary(): print diagnostic information like quantiles, effective sample size, and the Gelman-Rubin diagnostic.\nget_samples(): gets samples from the posterior distribution.\n\nNote:\n\nWe run inference with the NUTS sampler. To run vanilla HMC, we can instead use the HMC class.\n\n\n# Run NUTS\nkernel = NUTS(model)\nnum_samples = 2000 if not smoke_test else 2\nwarmup_steps=200 if not smoke_test else 2\nmcmc = MCMC(kernel, num_samples=num_samples, warmup_steps=warmup_steps)\n\n\nmcmc.run(\n    marriage=torch.tensor(dset.MarriageScaled.values, dtype=torch.float), \n    divorce=torch.tensor(dset.DivorceScaled.values, dtype=torch.float)\n)\nmcmc.summary()\nsamples_1 = mcmc.get_samples()\n\nSample: 100%|██████████| 2200/2200 [00:11, 195.90it/s, step size=8.56e-01, acc. prob=0.906]\n\n\n\n                mean       std    median      5.0%     95.0%     n_eff     r_hat\n         a      0.00      0.11      0.00     -0.17      0.19   2707.47      1.00\n        bM      0.35      0.12      0.35      0.14      0.55   1621.67      1.00\n     sigma      0.95      0.10      0.94      0.79      1.11   1390.63      1.00\n\nNumber of divergences: 0\n\n\n\n\n\n\n\nWe notice that the progress bar gives us online statistics on the acceptance probability, step size and number of steps taken per sample while running NUTS. In particular, during warmup, we adapt the step size and mass matrix to achieve a certain target acceptance probability which is 0.8, by default. We were able to successfully adapt our step size to achieve this target in the warmup phase.\nDuring warmup, the aim is to adapt hyper-parameters such as step size and mass matrix (the HMC algorithm is very sensitive to these hyper-parameters), and to reach the typical set (see [6] for more details). If there are any issues in the model specification, the first signal to notice would be low acceptance probabilities or very high number of steps. We use the sample from the end of the warmup phase to seed the MCMC chain (denoted by the second sample progress bar) from which we generate the desired number of samples from our target distribution.\nAt the end of inference, Pyro prints the mean, std and 90% CI values for each of the latent parameters. Note that since we standardized our predictors and response variable, we would expect the intercept to have mean 0, as can be seen here. It also prints other convergence diagnostics on the latent parameters in the model, effective sample size and the gelman rubin diagnostic (\\(\\hat{R}\\)). The value for these diagnostics indicates that the chain has converged to the target distribution. In our case, the “target distribution” is the posterior distribution over the latent parameters that we are interested in. Note that this is often worth verifying with multiple chains for more complicated models. In the end, samples_1 is a collection (in our case, a dict since init_samples was a dict) containing samples from the posterior distribution for each of the latent parameters in the model.\nTo look at our regression fit, let us plot the regression line using our posterior estimates for the regression parameters, along with the 90% Credibility Interval (CI). Note that the hpdi function in Pyro’s Statistical Utilities module can be used to compute CI. In the functions below, note that the collected samples from the posterior are all along the leading axis.\n\ndef plot_regression(x, y_mean, y_hpdi):\n    # Sort values for plotting by x axis\n    idx = np.argsort(x)\n    marriage = x[idx]\n    mean = y_mean[idx]\n    hpdi = y_hpdi[:, idx]\n    divorce = dset.DivorceScaled.values[idx]\n\n    # Plot\n    fig, ax = plt.subplots(nrows=1, ncols=1, figsize=(6, 6))\n    ax.plot(marriage, mean)\n    ax.plot(marriage, divorce, \"o\")\n    ax.fill_between(marriage, hpdi[0], hpdi[1], alpha=0.3, interpolate=True)\n    return ax\n\n# Compute empirical posterior distribution over mu\nposterior_mu = (\n    torch.unsqueeze(samples_1[\"a\"], -1)\n    + torch.unsqueeze(samples_1[\"bM\"], -1) * dset.MarriageScaled.values\n)\nmean_mu = torch.mean(posterior_mu, axis=0)\nhpdi_mu = stats.hpdi(posterior_mu, 0.9)\nax = plot_regression(dset.MarriageScaled.values, mean_mu, hpdi_mu)\nax.set(\n    xlabel=\"Marriage rate\", ylabel=\"Divorce rate\", title=\"Regression line with 90% CI\" \n);\n\n\n\n\nWe can see from the plot, that the CI broadens towards the tails where the data is relatively sparse, as can be expected.\n\n\n\nLet us check that we have set sensible priors by sampling from the prior predictive distribution. Pyro provides a handy Predictive utility for this purpose.\n\nfrom pyro.infer import Predictive\n\nprior_predictive = Predictive(model, num_samples=100)\nprior_predictions = prior_predictive(marriage=torch.tensor(dset.MarriageScaled.values, dtype=torch.float))[\n    \"obs\"\n]\nmean_prior_pred = torch.mean(prior_predictions, axis=0)\nhpdi_prior_pred = stats.hpdi(prior_predictions, 0.9)\n\nax = plot_regression(dset.MarriageScaled.values, mean_prior_pred, hpdi_prior_pred)\nax.set(xlabel=\"Marriage rate\", ylabel=\"Divorce rate\", title=\"Predictions with 90% CI\");\n\n\n\n\n\n\n\n\nLet us now look at the posterior predictive distribution to see how our predictive distribution looks with respect to the observed divorce rates. To get samples from the posterior predictive distribution, we need to run the model by substituting the latent parameters with samples from the posterior. Note that by default we generate a single prediction for each sample from the joint posterior distribution, but this can be controlled using the num_samples argument.\n\npredictive = Predictive(model=model, posterior_samples=samples_1)\npredictions = predictive(marriage=torch.tensor(dset.MarriageScaled.values, dtype=torch.float))[\"obs\"]\ndf = dset.filter([\"Location\"])\ndf[\"Mean Predictions\"] = torch.mean(predictions, axis=0)\ndf.head()\n\n\n\n\n\n  \n    \n      \n      Location\n      Mean Predictions\n    \n  \n  \n    \n      0\n      Alabama\n      0.024132\n    \n    \n      1\n      Alaska\n      0.511163\n    \n    \n      2\n      Arizona\n      0.040832\n    \n    \n      3\n      Arkansas\n      0.559602\n    \n    \n      4\n      California\n      -0.124215\n    \n  \n\n\n\n\n\n\nTo remove the magic behind Predictive, let us see how we can use Poutine (Effect Handlers). Unlike NumPyro, where we could combine the effect handlers with the vmap JAX primitive to implement our own simplified predictive utility function that can do vectorized predictions, here we use a native for-loop to show the same implementation.\n\ndef predict(post_samples, model, *args, **kwargs):\n    conditioned_model = poutine.condition(model, post_samples)\n    model_trace = poutine.trace(conditioned_model).get_trace(*args, **kwargs)\n    return model_trace.nodes[\"obs\"][\"value\"]\n\ndef predict_fn(post_samples):\n    with pyro.plate(\"samples\", num_samples):\n        return predict(post_samples, model, marriage=torch.reshape(torch.tensor(dset.MarriageScaled.values, \n                                            dtype=torch.float), (-1, 1)))\n\nNote the use of the condition and trace effect handlers in the predict function.\n\nThe condition effect handler conditions the latent sample sites to certain values. In our case, we are conditioning on values from the posterior distribution returned by MCMC.\nThe trace effect handler runs the model and records the execution trace within an OrderedDict. This trace object contains execution metadata that is useful for computing quantities such as the log joint density.\n\nIt should be clear now that the predict function simply runs the model by substituting the latent parameters with samples from the posterior (generated by the mcmc function) to generate predictions. Each draw from the posterior can be used to get predictions over all the 50 states. We get a predictions_1 array of shape (num_samples, 50). We can then compute the mean and 90% CI of these samples to plot the posterior predictive distribution. We note that our mean predictions are similar to those obtained from the Predictive utility class.\n\npredictions_1 = predict_fn(samples_1)\n\nmean_pred = torch.mean(predictions_1, axis=1)\ndf = dset.filter([\"Location\"])\ndf[\"Mean Predictions\"] = mean_pred\ndf.head()\n\n\n\n\n\n  \n    \n      \n      Location\n      Mean Predictions\n    \n  \n  \n    \n      0\n      Alabama\n      -0.003167\n    \n    \n      1\n      Alaska\n      0.497712\n    \n    \n      2\n      Arizona\n      -0.000853\n    \n    \n      3\n      Arkansas\n      0.572533\n    \n    \n      4\n      California\n      -0.075509\n    \n  \n\n\n\n\n\nhpdi_pred = stats.hpdi(predictions_1, 0.9)\nax = plot_regression(dset.MarriageScaled.values, mean_pred, hpdi_pred)\nax.set(xlabel=\"Marriage rate\", \n        ylabel=\"Divorce rate\", \n        title=\"Predictions with 90% CI\");\n\n\n\n\nWe have used the same plot_regression function as earlier. We notice that our CI for the predictive distribution is much broader as compared to the last plot due to the additional noise introduced by the sigma parameter. Most data points lie well within the 90% CI, which indicates a good fit.\n\n\n\nLikewise, making use of effect-handlers, we can also compute the log likelihood for this model given the dataset, and the log posterior predictive density [6] which is given by \\[ log \\prod_{i=1}^{n} \\int p(y_i | \\theta) p_{post}(\\theta) d\\theta\n\\approx \\sum_{i=1}^n log \\frac{\\sum_s p(\\theta^{s})}{S} \\\\\n= \\sum_{i=1}^n (log \\sum_s p(\\theta^{s}) - log(S))\n\\].\nHere, \\(i\\) indexes the observed data points \\(y\\) and \\(s\\) indexes the posterior samples over the latent parameters \\(\\theta\\). If the posterior predictive density for a model has a comparatively high value, it indicates that the observed data-points have higher probability under the given model.\n\ndef log_likelihood(params, model, *args, **kwargs):\n    model = poutine.condition(model, params)\n    model_trace = poutine.trace(model).get_trace(*args, **kwargs)\n    obs_node = model_trace.nodes[\"obs\"]\n    return obs_node[\"fn\"].log_prob(obs_node[\"value\"])\n\ndef log_pred_density_helper(params, model, n, var_not_used=None, *args, **kwargs):\n    single_param = {}\n    tmp_tensor = torch.empty(size=(num_samples, 50))\n    for i in range(n):\n        if var_not_used == 'age':\n            single_param = {\"a\": params[\"a\"][i], \"bM\": params[\"bM\"][i], \"sigma\": params[\"sigma\"][i]}\n        elif var_not_used == 'marriage':\n            single_param = {\"a\": params[\"a\"][i], \"bA\": params[\"bA\"][i], \"sigma\": params[\"sigma\"][i]}\n        else:\n            single_param = {\"a\": params[\"a\"][i], \"bM\": params[\"bM\"][i], \"bA\": params[\"bA\"][i], \"sigma\": params[\"sigma\"][i]}\n        tmp_tensor[i] = log_likelihood(single_param, model, *args, **kwargs)\n    return tmp_tensor\n\n\n\ndef log_pred_density(params, model, var_not_used=None, *args, **kwargs):\n    n = list(params.values())[0].shape[0]\n    log_lk_vals = log_pred_density_helper(params, model, n, var_not_used, *args, **kwargs)\n    return (torch.logsumexp(log_lk_vals, 0) - np.log(n)).sum()\n\n\nprint(\n    \"Log posterior predictive density: {}\".format(\n        log_pred_density(samples_1, \n                        model, \n                        var_not_used='age',\n                        marriage=torch.tensor(dset.MarriageScaled.values, dtype=torch.float),\n                        divorce=torch.tensor(dset.DivorceScaled.values, dtype=torch.float)\n                    )\n    )\n)\n\nLog posterior predictive density: -66.72371673583984\n\n\nIn this tutorial, we would like to emphasize that there is nothing magical about utility functions available in Pyro, and you can roll out your own inference utilities using Pyro’s effect handling stack.\n\n\n\nThe objective of variational inference is to pick a family of distributions with its own parameters to approximate the true posterior distribution. Then we find the parameter values which make the approximate distribution close the the true posterior. We carry out the steps below to define the model, extract the samples and plot the regression line. The only notable difference is that we define a guide to approximate the posterior. For this we use one of Pyro’s autoguides - AutoDiagonalNormal.\n\npyro.set_rng_seed(1)\n\nfrom pyro.infer import SVI, Trace_ELBO\nfrom pyro.infer.autoguide import AutoDiagonalNormal\n\nlearing_rate = 1e-4\n\nguide = AutoDiagonalNormal(model)\n\nnum_iter = 7000 if not smoke_test else 2\n\nsvi = SVI(\n    model,\n    guide,\n    optim.Adam({\"lr\": learing_rate}),\n    loss=Trace_ELBO()\n)\n\nloss = np.empty(num_iter)\n\npyro.clear_param_store()\nfor step in range(num_iter):\n    loss[step] = svi.step(\n        marriage=torch.tensor(dset.MarriageScaled.values, dtype=torch.float),\n        divorce=torch.tensor(dset.DivorceScaled.values, dtype=torch.float)\n    )\n    if step % 1000 == 0:\n        print(f'step: {step:>5}, ELBO loss: {loss[step]:.2f}')\n\nstep:     0, ELBO loss: 102.63\nstep:  1000, ELBO loss: 87.01\nstep:  2000, ELBO loss: 76.31\nstep:  3000, ELBO loss: 75.36\nstep:  4000, ELBO loss: 77.44\nstep:  5000, ELBO loss: 73.24\nstep:  6000, ELBO loss: 73.90\n\n\n\n# Plot the loss curve\nplt.plot(loss)\nplt.xlabel('step')\nplt.ylabel('ELBO Loss');\n\n\n\n\nWe sample from the posterior distribution of the regression parameters of the model using the Predictive utility.\n\nposterior_svi = Predictive(model, guide=guide, num_samples=num_samples)\nsamples_1_svi = {k: v.reshape(num_samples)\n                   for k, v in posterior_svi(\n                       marriage=torch.tensor(dset.MarriageScaled.values, dtype=torch.float),\n                       divorce=torch.tensor(dset.DivorceScaled.values, dtype=torch.float)\n                   ).items()\n                   if k != \"obs\"}\n\nLet us look at the regression fit of the SVI model. We plot the regression line using our posterior estimates for the regression parameters, along with the 90% Credibility Interval (CI). We can see that the regression fit is very similar to what we got for the NUTS model earlier.\n\n# Compute empirical posterior distribution over mu\nposterior_mu_svi = (\n    torch.unsqueeze(samples_1_svi[\"a\"], -1)\n    + torch.unsqueeze(samples_1_svi[\"bM\"], -1) * dset.MarriageScaled.values\n)\nmean_mu_svi = torch.mean(posterior_mu_svi, axis=0)\nhpdi_mu_svi = stats.hpdi(posterior_mu_svi, 0.9)\nax = plot_regression(dset.MarriageScaled.values, mean_mu_svi, hpdi_mu_svi)\nax.set(\n    xlabel=\"Marriage rate\", ylabel=\"Divorce rate\", title=\"Regression line with 90% CI\" \n);\n\n\n\n\n\n\n\n\nWe will now model the divorce rate as a function of the median age of marriage. The computations are mostly a reproduction of what we did for Model 1. Notice the following:\n\nDivorce rate is inversely related to the age of marriage. Hence states where the median age of marriage is low will likely have a higher divorce rate.\nWe get a higher log likelihood as compared to Model 2, indicating that median age of marriage is likely a much better predictor of divorce rate.\n\n\n# Run NUTS\nkernel = NUTS(model)\nnum_samples = 2000 if not smoke_test else 2\nwarmup_steps=200 if not smoke_test else 2\nmcmc = MCMC(kernel, num_samples=num_samples, warmup_steps=warmup_steps)\n\n\nmcmc.run(\n    age=torch.tensor(dset.AgeScaled.values, dtype=torch.float), \n    divorce=torch.tensor(dset.DivorceScaled.values, dtype=torch.float)\n)\nmcmc.summary()\nsamples_2 = mcmc.get_samples()\n\nSample: 100%|██████████| 2200/2200 [00:12, 175.14it/s, step size=7.52e-01, acc. prob=0.921]\n\n\n\n                mean       std    median      5.0%     95.0%     n_eff     r_hat\n         a     -0.00      0.10      0.00     -0.16      0.16   1865.24      1.00\n        bA     -0.57      0.11     -0.57     -0.76     -0.40   1618.48      1.00\n     sigma      0.82      0.09      0.82      0.67      0.95   1355.84      1.00\n\nNumber of divergences: 0\n\n\n\n\n\n\nposterior_mu = (\n    torch.unsqueeze(samples_2[\"a\"], -1)\n    + torch.unsqueeze(samples_2[\"bA\"], -1) * dset.AgeScaled.values\n)\nmean_mu = torch.mean(posterior_mu, axis=0)\nhpdi_mu = stats.hpdi(posterior_mu, 0.9)\nax = plot_regression(dset.AgeScaled.values, mean_mu, hpdi_mu)\nax.set(\n    xlabel=\"Median marriage age\", \n    ylabel=\"Divorce rate\", \n    title=\"Regression line with 90% CI\" \n);\n\n\n\n\n\npredictive_2 = Predictive(model, samples_2)\npredictions_2 = predictive_2(age=torch.tensor(dset.AgeScaled.values, dtype=torch.float))[\"obs\"]\n\nmean_pred = torch.mean(predictions_2, axis=0)\nhpdi_pred = stats.hpdi(predictions_2, 0.9)\n\nax = plot_regression(dset.AgeScaled.values, mean_pred, hpdi_pred)\nax.set(xlabel=\"Median Age\", ylabel=\"Divorce rate\", title=\"Predictions with 90% CI\");\n\n\n\n\n\nprint(\n    \"Log posterior predictive density: {}\".format(\n        log_pred_density(samples_2, \n                        model, \n                        var_not_used='marriage',\n                        age=torch.tensor(dset.AgeScaled.values, dtype=torch.float),\n                        divorce=torch.tensor(dset.DivorceScaled.values, dtype=torch.float)\n                    )\n    )\n)\n\nLog posterior predictive density: -59.240997314453125\n\n\n\n\n\nFinally, we will also model divorce rate as depending on both marriage rate as well as the median age of marriage. Note that the model’s posterior predictive density is similar to Model 2 which likely indicates that the marginal information from marriage rate in predicting divorce rate is low when the median age of marriage is already known.\n\n# Run NUTS\nkernel = NUTS(model)\nnum_samples = 2000 if not smoke_test else 2\nwarmup_steps=200 if not smoke_test else 2\nmcmc = MCMC(kernel, num_samples=num_samples, warmup_steps=warmup_steps)\n\n\nmcmc.run(\n    marriage=torch.tensor(dset.MarriageScaled.values, dtype=torch.float), \n    age=torch.tensor(dset.AgeScaled.values, dtype=torch.float), \n    divorce=torch.tensor(dset.DivorceScaled.values, dtype=torch.float)\n)\nmcmc.summary()\nsamples_3 = mcmc.get_samples()\n\nSample: 100%|██████████| 2200/2200 [00:17, 125.32it/s, step size=6.45e-01, acc. prob=0.906]\n\n\n\n                mean       std    median      5.0%     95.0%     n_eff     r_hat\n         a     -0.00      0.10     -0.00     -0.16      0.17   2052.14      1.00\n        bA     -0.60      0.15     -0.61     -0.84     -0.36   1583.09      1.00\n        bM     -0.06      0.15     -0.06     -0.29      0.21   1526.50      1.00\n     sigma      0.82      0.09      0.81      0.69      0.97   1719.60      1.00\n\nNumber of divergences: 0\n\n\n\n\n\n\nprint(\n    \"Log posterior predictive density: {}\".format(\n        log_pred_density(samples_3, \n                        model, \n                        # var_not_used='marriage',\n                        marriage=torch.tensor(dset.MarriageScaled.values, dtype=torch.float),\n                        age=torch.tensor(dset.AgeScaled.values, dtype=torch.float),\n                        divorce=torch.tensor(dset.DivorceScaled.values, dtype=torch.float)\n                    )\n    )\n)\n\nLog posterior predictive density: -59.04816436767578\n\n\n\n\n\nThe regression plots above shows that the observed divorce rates for many states differs considerably from the mean regression line. To dig deeper into how the last model (Model 3) under-predicts or over-predicts for each of the states, we will plot the posterior predictive and residuals (Observed divorce rate - Predicted divorce rate) for each of the states.\n\n# Predictions for Model 3\npredictive_3 = Predictive(model, samples_3)\npredictions_3 = predictive_3(marriage=dset.MarriageScaled.values, age=dset.AgeScaled.values)[\"obs\"]\n\n\ny = torch.arange(50)\n\nfig, ax = plt.subplots(nrows=1, ncols=2, figsize=(12, 16))\npred_mean = torch.mean(predictions_3, axis=0)\npred_hpdi = stats.hpdi(predictions_3, 0.9)\nresiduals_3 = torch.tensor(dset.DivorceScaled.values, dtype=torch.float) - predictions_3\nresiduals_mean = torch.mean(residuals_3, axis=0)\nresiduals_hpdi = stats.hpdi(residuals_3, 0.9)\nidx = torch.argsort(residuals_mean)\n\n# Plot posterior predictive\nax[0].plot(torch.zeros(50), y, \"--\")\nax[0].errorbar(\n    pred_mean[idx],\n    y,\n    xerr=pred_hpdi[1, idx] - pred_mean[idx],\n    marker=\"o\",\n    ms=5,\n    mew=4,\n    ls=\"none\",\n    alpha=0.8,\n)\nax[0].plot(dset.DivorceScaled.values[idx], y, marker=\"o\", ls=\"none\", color=\"gray\")\nax[0].set(\n    xlabel=\"Posterior Predictive (red) vs. Actuals (gray)\",\n    ylabel=\"State\",\n    title=\"Posterior Predictive with 90% CI\",\n)\nax[0].set_yticks(y)\nax[0].set_yticklabels(dset.Loc.values[idx], fontsize=10)\n\n# Plot residuals\nresiduals_3 = torch.tensor(dset.DivorceScaled.values, dtype=torch.float) - predictions_3\nresiduals_mean = torch.mean(residuals_3, axis=0)\nresiduals_hpdi = stats.hpdi(residuals_3, 0.9)\nerr = residuals_hpdi[1] - residuals_mean\n\nax[1].plot(torch.zeros(50), y, \"--\")\nax[1].errorbar(\n    residuals_mean[idx], y, xerr=err[idx], marker=\"o\", ms=5, mew=4, ls=\"none\", alpha=0.8\n)\nax[1].set(xlabel=\"Residuals\", ylabel=\"State\", title=\"Residuals with 90% CI\")\nax[1].set_yticks(y)\nax[1].set_yticklabels(dset.Loc.values[idx], fontsize=10);\n\n\n\n\nThe plot on the left shows the mean predictions with 90% CI for each of the states using Model 3. The gray markers indicate the actual observed divorce rates. The right plot shows the residuals for each of the states, and both these plots are sorted by the residuals, i.e. at the bottom, we are looking at states where the model predictions are higher than the observed rates, whereas at the top, the reverse is true.\nOverall, the model fit seems good because most observed data points like within a 90% CI around the mean predictions. However, notice how the model over-predicts by a large margin for states like Idaho (bottom left), and on the other end under-predicts for states like Maine (top right). This is likely indicative of other factors that we are missing out in our model that affect divorce rate across different states. Even ignoring other socio-political variables, one such factor that we have not yet modeled is the measurement noise given by Divorce SE in the dataset. We will explore this in the next section.\n\n\n\n\nNote that in our previous models, each data point influences the regression line equally. Is this well justified? We will build on the previous model to incorporate measurement error given by Divorce SE variable in the dataset. Incorporating measurement noise will be useful in ensuring that observations that have higher confidence (i.e. lower measurement noise) have a greater impact on the regression line. On the other hand, this will also help us better model outliers with high measurement errors. For more details on modeling errors due to measurement noise, refer to Chapter 14 of [1].\nTo do this, we will reuse Model 3, with the only change that the final observed value has a measurement error given by divorce_sd (notice that this has to be standardized since the divorce variable itself has been standardized to mean 0 and std 1).\n\ndef model_se(marriage, age, divorce_sd, divorce=None):\n    a = pyro.sample(\"a\", dist.Normal(0.0, 0.2))\n    bM = pyro.sample(\"bM\", dist.Normal(0.0, 0.5))\n    M = bM * marriage\n    bA = pyro.sample(\"bA\", dist.Normal(0.0, 0.5))\n    A = bA * age\n    sigma = pyro.sample(\"sigma\", dist.Exponential(1.0))\n    mu = a + M + A\n    divorce_rate = pyro.sample(\"divorce_rate\", dist.Normal(mu, sigma))\n    pyro.sample(\"obs\", dist.Normal(divorce_rate, divorce_sd), obs=divorce)\n\n\n# Standardize\ndset[\"DivorceScaledSD\"] = dset[\"Divorce SE\"] / np.std(dset.Divorce.values)\n\n\nnum_samples=3000 if not smoke_test else 2\nwarmup_steps=1000 if not smoke_test else 2\nkernel = NUTS(model_se, target_accept_prob=0.9)\nmcmc = MCMC(kernel, warmup_steps=warmup_steps, num_samples=num_samples)\nmcmc.run(\n    marriage=torch.tensor(dset.MarriageScaled.values, dtype=torch.float), \n    age=torch.tensor(dset.AgeScaled.values, dtype=torch.float), \n    divorce_sd=torch.tensor(dset.DivorceScaledSD, dtype=torch.float),\n    divorce=torch.tensor(dset.DivorceScaled.values, dtype=torch.float)\n)\nmcmc.summary()\nsamples_4 = mcmc.get_samples()\n\nSample: 100%|██████████| 4000/4000 [01:26, 46.32it/s, step size=2.66e-01, acc. prob=0.934]\n\n\n\n                      mean       std    median      5.0%     95.0%     n_eff     r_hat\n               a     -0.05      0.10     -0.05     -0.22      0.10   2892.05      1.00\n              bA     -0.61      0.16     -0.61     -0.87     -0.35   1764.01      1.00\n              bM      0.06      0.17      0.06     -0.22      0.32   1698.03      1.00\n divorce_rate[0]      1.15      0.37      1.14      0.52      1.73   4101.30      1.00\n divorce_rate[1]      0.68      0.54      0.66     -0.20      1.52   4700.64      1.00\n divorce_rate[2]      0.43      0.33      0.43     -0.09      1.00   5579.89      1.00\n divorce_rate[3]      1.41      0.45      1.40      0.64      2.15   4928.70      1.00\n divorce_rate[4]     -0.90      0.13     -0.90     -1.10     -0.68   5104.04      1.00\n divorce_rate[5]      0.65      0.40      0.64      0.01      1.33   4066.76      1.00\n divorce_rate[6]     -1.36      0.35     -1.35     -2.00     -0.83   5605.81      1.00\n divorce_rate[7]     -0.32      0.49     -0.31     -1.12      0.47   4610.33      1.00\n divorce_rate[8]     -1.88      0.60     -1.88     -2.85     -0.92   2866.64      1.00\n divorce_rate[9]     -0.62      0.17     -0.62     -0.89     -0.34   5923.41      1.00\ndivorce_rate[10]      0.75      0.29      0.75      0.28      1.23   4697.33      1.00\ndivorce_rate[11]     -0.53      0.48     -0.53     -1.39      0.22   3437.37      1.00\ndivorce_rate[12]      0.21      0.49      0.22     -0.57      1.03   2057.42      1.00\ndivorce_rate[13]     -0.86      0.23     -0.86     -1.27     -0.53   7300.48      1.00\ndivorce_rate[14]      0.55      0.31      0.55      0.01      1.04   4580.96      1.00\ndivorce_rate[15]      0.28      0.38      0.29     -0.41      0.86   6245.29      1.00\ndivorce_rate[16]      0.50      0.43      0.50     -0.20      1.20   5173.23      1.00\ndivorce_rate[17]      1.24      0.35      1.23      0.72      1.85   3672.41      1.00\ndivorce_rate[18]      0.42      0.38      0.41     -0.18      1.06   5871.63      1.00\ndivorce_rate[19]      0.38      0.53      0.37     -0.48      1.24   2655.37      1.00\ndivorce_rate[20]     -0.56      0.31     -0.56     -1.05     -0.03   4313.36      1.00\ndivorce_rate[21]     -1.10      0.27     -1.10     -1.51     -0.64   4575.67      1.00\ndivorce_rate[22]     -0.27      0.26     -0.27     -0.70      0.15   5345.20      1.00\ndivorce_rate[23]     -1.00      0.30     -1.00     -1.47     -0.50   4594.95      1.00\ndivorce_rate[24]      0.42      0.41      0.40     -0.24      1.08   4888.42      1.00\ndivorce_rate[25]     -0.03      0.30     -0.02     -0.52      0.47   5341.36      1.00\ndivorce_rate[26]     -0.03      0.50     -0.03     -0.78      0.84   4283.69      1.00\ndivorce_rate[27]     -0.15      0.39     -0.14     -0.78      0.49   4833.08      1.00\ndivorce_rate[28]     -0.27      0.49     -0.27     -1.08      0.54   3475.12      1.00\ndivorce_rate[29]     -1.79      0.23     -1.79     -2.17     -1.41   5616.94      1.00\ndivorce_rate[30]      0.18      0.42      0.17     -0.53      0.85   5533.95      1.00\ndivorce_rate[31]     -1.66      0.17     -1.66     -1.94     -1.39   5818.72      1.00\ndivorce_rate[32]      0.12      0.24      0.12     -0.28      0.51   5921.18      1.00\ndivorce_rate[33]     -0.03      0.50     -0.00     -0.82      0.84   3123.85      1.00\ndivorce_rate[34]     -0.12      0.22     -0.12     -0.49      0.22   4427.76      1.00\ndivorce_rate[35]      1.26      0.40      1.25      0.61      1.90   4695.57      1.00\ndivorce_rate[36]      0.22      0.35      0.22     -0.34      0.82   5018.34      1.00\ndivorce_rate[37]     -1.03      0.22     -1.03     -1.36     -0.66   4955.84      1.00\ndivorce_rate[38]     -0.93      0.54     -0.95     -1.91     -0.12   3953.88      1.00\ndivorce_rate[39]     -0.68      0.32     -0.67     -1.23     -0.18   6472.10      1.00\ndivorce_rate[40]      0.24      0.54      0.24     -0.59      1.20   4899.75      1.00\ndivorce_rate[41]      0.74      0.34      0.73      0.17      1.30   3620.41      1.00\ndivorce_rate[42]      0.20      0.18      0.19     -0.10      0.51   6072.49      1.00\ndivorce_rate[43]      0.82      0.43      0.82      0.13      1.54   3248.31      1.00\ndivorce_rate[44]     -0.42      0.53     -0.41     -1.27      0.44   4783.05      1.00\ndivorce_rate[45]     -0.39      0.26     -0.39     -0.87     -0.01   6733.07      1.00\ndivorce_rate[46]      0.13      0.29      0.13     -0.37      0.58   6125.59      1.00\ndivorce_rate[47]      0.56      0.46      0.55     -0.15      1.32   5691.95      1.00\ndivorce_rate[48]     -0.63      0.28     -0.63     -1.11     -0.21   4968.47      1.00\ndivorce_rate[49]      0.87      0.57      0.88     -0.09      1.78   2810.28      1.00\n           sigma      0.58      0.11      0.57      0.38      0.73   1217.76      1.00\n\nNumber of divergences: 0\n\n\n\n\nNotice that our values for the regression coefficients is very similar to Model 3. However, introducing measurement noise allows us to more closely match our predictive distribution to the observed values. We can see this if we plot the residuals as earlier.\n\n# Predictions for Model SE\npredictive_4 = Predictive(model_se, samples_4)\npredictions_4 = predictive_4(\n    marriage=torch.tensor(dset.MarriageScaled.values, dtype=torch.float), \n    age=torch.tensor(dset.AgeScaled.values, dtype=torch.float),\n    divorce_sd=torch.tensor(dset.DivorceScaledSD.values, dtype=torch.float),\n    )[\"obs\"]\n\n\nsd = torch.tensor(dset.DivorceScaledSD.values, dtype=torch.float)\nresiduals_4 = torch.tensor(dset.DivorceScaled.values, dtype=torch.float) - predictions_4\nresiduals_mean = torch.mean(residuals_4, axis=0)\nresiduals_hpdi = stats.hpdi(residuals_4, 0.9)\nerr = residuals_hpdi[1] - residuals_mean\nidx = torch.argsort(residuals_mean)\ny = torch.arange(50)\nfig, ax = plt.subplots(nrows=1, ncols=1, figsize=(6, 16))\n\n\n# Plot Residuals\nax.plot(torch.zeros(50), y, \"--\")\nax.errorbar(\n    residuals_mean[idx], y, xerr=err[idx], marker=\"o\", ms=5, mew=4, ls=\"none\", alpha=0.8\n)\n\n# Plot SD\nax.errorbar(residuals_mean[idx], y, xerr=sd[idx], ls=\"none\", color=\"orange\", alpha=0.9)\n\n# Plot earlier mean residual\nax.plot(\n    torch.mean(torch.tensor(dset.DivorceScaled.values, dtype=torch.float) - predictions_3, 0)[idx],\n    y,\n    ls=\"none\",\n    marker=\"o\",\n    ms=6,\n    color=\"black\",\n    alpha=0.6,\n)\n\nax.set(xlabel=\"Residuals\", ylabel=\"State\", title=\"Residuals with 90% CI\")\nax.set_yticks(y)\nax.set_yticklabels(dset.Loc.values[idx], fontsize=10)\nax.text(\n    -2.8,\n    -7,\n    \"Residuals (with error-bars) from current model (in red). \"\n    \"Black marker \\nshows residuals from the previous model (Model 3). \"\n    \"Measurement \\nerror is indicated by orange bar.\",\n);\n\n\n\n\nThe plot above shows the residuals for each of the states, along with the measurement noise given by inner error bar. The gray dots are the mean residuals from our earlier Model 3. Notice how having an additional degree of freedom to model the measurement noise has shrunk the residuals. In particular, for Idaho and Maine, our predictions are now much closer to the observed values after incorporating measurement noise in the model.\nTo better see how measurement noise affects the movement of the regression line, let us plot the residuals with respect to the measurement noise.\n\nfig, ax = plt.subplots(nrows=1, ncols=1, figsize=(10, 6))\nx = torch.tensor(dset.DivorceScaledSD.values, dtype=torch.float)\ny1 = torch.mean(residuals_3, 0)\ny2 = torch.mean(residuals_4, 0)\nax.plot(x, y1, ls=\"none\", marker=\"o\")\nax.plot(x, y2, ls=\"none\", marker=\"o\")\nfor i, (j, k) in enumerate(zip(y1, y2)):\n    ax.plot([x[i], x[i]], [j, k], \"--\", color=\"gray\")\n\nax.set(\n    xlabel=\"Measurement Noise\",\n    ylabel=\"Residual\",\n    title=\"Mean residuals (Model 4: red, Model 3: blue)\",\n);\n\n\n\n\nThe plot above shows what has happened in more detail - the regression line itself has moved to ensure a better fit for observations with low measurement noise (left of the plot) where the residuals have shrunk very close to 0. That is to say that data points with low measurement error have a concomitantly higher contribution in determining the regression line. On the other hand, for states with high measurement error (right of the plot), incorporating measurement noise allows us to move our posterior distribution mass closer to the observations resulting in a shrinkage of residuals as well.\n\n\n\n\n\nMcElreath, R. (2016). Statistical Rethinking: A Bayesian Course with Examples in R and Stan CRC Press.\nStan Development Team. Stan User’s Guide\nGoodman, N.D., and StuhlMueller, A. (2014). The Design and Implementation of Probabilistic Programming Languages\nPyro Development Team. Poutine: A Guide to Programming with Effect Handlers in Pyro\nHoffman, M.D., Gelman, A. (2011). The No-U-Turn Sampler: Adaptively Setting Path Lengths in Hamiltonian Monte Carlo.\nBetancourt, M. (2017). A Conceptual Introduction to Hamiltonian Monte Carlo.\nJAX Development Team (2018). Composable transformations of Python+NumPy programs: differentiate, vectorize, JIT to GPU/TPU, and more\nGelman, A., Hwang, J., and Vehtari A. Understanding predictive information criteria for Bayesian models"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Arijeet Chatterjee",
    "section": "",
    "text": "I am currently a data scientist working on data science and machine learning projects in retail."
  },
  {
    "objectID": "index.html#education",
    "href": "index.html#education",
    "title": "Arijeet Chatterjee",
    "section": "Education",
    "text": "Education\nUniversity of British Columbia | Vancouver, Canada Master of Data Science | Sept 2021 - June 2022\nHEC Paris | France MBA | Sept 2008 - May 2010"
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "Blog",
    "section": "",
    "text": "Bayesian Regression Using Pyro\n\n\n\n\n\n\n\nBayesian Regression\n\n\nPyro\n\n\n\n\nAn example of Bayesian regression adapted from a NumPyro tutorial. In this tutorial I use Pyro. This tutorial was developed as an open source contribution for Pyro.\n\n\n\n\n\n\nApr 8, 2023\n\n\n\n\n\n\nNo matching items"
  }
]