[
  {
    "objectID": "posts/bayes-regression/bayesian_regression_mcmc_and_svi.html",
    "href": "posts/bayes-regression/bayesian_regression_mcmc_and_svi.html",
    "title": "Bayesian Regression Using Pyro",
    "section": "",
    "text": "In this tutorial, we will explore how to do bayesian regression in Pyro, using a simple example adapted from Statistical Rethinking [1]. In particular, we would like to explore the following:\n\nWrite a simple model using the sample Pyro primitive.\nRun inference using MCMC in Pyro, in particular, using the No U-Turn Sampler (NUTS) to get a posterior distribution over our regression parameters of interest. We also show an example of inference using Pyro’s SVI.\nLearn about inference utilities such as Predictive and log_likelihood.\nLearn how we can use effect-handlers in Pyro to generate execution traces from the model, condition on sample statements, etc., and use this to implement various utilities that will be useful for MCMC. e.g. computing model log likelihood, generating empirical distribution over the posterior predictive, etc.\n\n\n\n\nDataset\nRegression Model to Predict Divorce Rate\n\nModel-1: Predictor-Marriage Rate\n\nPosterior Distribution over the Regression Parameters\nPrior Predictive Distribution\nPosterior Predictive Distribution\nPredictive Utility With Effect Handlers\nModel Predictive Density\nRegression with Pyro’s Stochastic Variational Inference (SVI)\n\nModel-2: Predictor-Median Age of Marriage\nModel-3: Predictor-Marriage Rate and Median Age of Marriage\nDivorce Rate Residuals by State\n\nRegression Model with Measurement Error\n\nEffect of Incorporating Measurement Noise on Residuals\n\nReferences\n\n\nimport os\n\nfrom IPython.display import set_matplotlib_formats\nimport torch\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nfrom torch import logsumexp\n\nimport pyro\nimport pyro.distributions as dist\nimport pyro.poutine as poutine\nimport pyro.optim as optim\nfrom pyro.infer import HMC, NUTS, MCMC\nimport pyro.ops.stats as stats\n\nplt.style.use(\"bmh\")\n\nassert pyro.__version__.startswith('1.8.0')\nsmoke_test = ('CI' in os.environ)\npyro.set_rng_seed(1)\n\n\n\n\nFor this example, we will use the WaffleDivorce dataset from Chapter 05, Statistical Rethinking [1]. The dataset contains divorce rates in each of the 50 states in the USA, along with predictors such as population, median age of marriage, whether it is a Southern state and, curiously, number of Waffle Houses.\n\nDATASET_URL = \"https://raw.githubusercontent.com/rmcelreath/rethinking/master/data/WaffleDivorce.csv\"\ndset = pd.read_csv(DATASET_URL, sep=\";\")\ndset.head()\n\n\n\n\n\n  \n    \n      \n      Location\n      Loc\n      Population\n      MedianAgeMarriage\n      Marriage\n      Marriage SE\n      Divorce\n      Divorce SE\n      WaffleHouses\n      South\n      Slaves1860\n      Population1860\n      PropSlaves1860\n    \n  \n  \n    \n      0\n      Alabama\n      AL\n      4.78\n      25.3\n      20.2\n      1.27\n      12.7\n      0.79\n      128\n      1\n      435080\n      964201\n      0.45\n    \n    \n      1\n      Alaska\n      AK\n      0.71\n      25.2\n      26.0\n      2.93\n      12.5\n      2.05\n      0\n      0\n      0\n      0\n      0.00\n    \n    \n      2\n      Arizona\n      AZ\n      6.33\n      25.8\n      20.3\n      0.98\n      10.8\n      0.74\n      18\n      0\n      0\n      0\n      0.00\n    \n    \n      3\n      Arkansas\n      AR\n      2.92\n      24.3\n      26.4\n      1.70\n      13.5\n      1.22\n      41\n      1\n      111115\n      435450\n      0.26\n    \n    \n      4\n      California\n      CA\n      37.25\n      26.8\n      19.1\n      0.39\n      8.0\n      0.24\n      0\n      0\n      0\n      379994\n      0.00\n    \n  \n\n\n\n\nLet us plot the pair-wise relationship amongst the main variables in the dataset, using seaborn.pairplot.\n\nvars = [\n    \"Population\",\n    \"MedianAgeMarriage\",\n    \"Marriage\",\n    \"WaffleHouses\",\n    \"South\",\n    \"Divorce\",\n]\nsns.pairplot(dset, x_vars=vars, y_vars=vars, palette=\"husl\");\n\n\n\n\nFrom the plots above, we can clearly observe that there is a relationship between divorce rates and marriage rates in a state (as might be expected), and also between divorce rates and median age of marriage.\nThere is also a weak relationship between number of Waffle Houses and divorce rates, which is not obvious from the plot above, but will be clearer if we regress Divorce against WaffleHouse and plot the results.\n\nsns.regplot(x=\"WaffleHouses\", y=\"Divorce\", data=dset);\n\n\n\n\nThis is an example of a spurious association. We do not expect the number of Waffle Houses in a state to affect the divorce rate, but it is likely correlated with other factors that have an effect on the divorce rate. We will not delve into this spurious association in this tutorial, but the interested reader is encouraged to read Chapters 5 and 6 of [1] which explores the problem of causal association in the presence of multiple predictors.\nFor simplicity, we will primarily focus on marriage rate and the median age of marriage as our predictors for divorce rate throughout the remaining tutorial.\n\n\n\nLet us now write a regression model in Pyro to predict the divorce rate as a linear function of marriage rate and median age of marriage in each of the states.\nFirst, note that our predictor variables have somewhat different scales. It is a good practice to standardize our predictors and response variables to mean 0 and standard deviation 1, which should result in faster inference.\n\nstandardize = lambda x: (x - x.mean()) / x.std()\n\ndset[\"AgeScaled\"] = dset.MedianAgeMarriage.pipe(standardize)\ndset[\"MarriageScaled\"] = dset.Marriage.pipe(standardize)\ndset[\"DivorceScaled\"] = dset.Divorce.pipe(standardize)\n\nWe write the Pyro model as follows. While the code should largely be self-explanatory, take note of the following:\n\nIn Pyro, model code is any Python callable which can optionally accept additional arguments and keywords. For HMC which we will be using for this tutorial, these arguments and keywords remain static during inference, but we can reuse the same model to generate predictions on new data.\nIn addition to regular Python statements, the model code also contains primitives like sample. These primitives can be interpreted with various side-effects using effect handlers. For more on effect handlers, refer to [3], [4]. For now, just remember that a sample statement makes this a stochastic function that samples some latent parameters from a prior distribution. Our goal is to infer the posterior distribution of these parameters conditioned on observed data.\nThe reason why we have kept our predictors as optional keyword arguments is to be able to reuse the same model as we vary the set of predictors. Likewise, the reason why the response variable is optional is that we would like to reuse this model to sample from the posterior predictive distribution. See the section on plotting the posterior predictive distribution, as an example.\n\n\ndef model(marriage=None, age=None, divorce=None):\n    a = pyro.sample(\"a\", dist.Normal(0.0, 0.2))\n    M, A = 0.0, 0.0\n    nums = 0\n    if age is not None:\n        nums = age.shape[0]\n        bA = pyro.sample(\"bA\", dist.Normal(0.0, 0.5))\n        A = bA * age\n    if marriage is not None:\n        nums = marriage.shape[0]\n        bM = pyro.sample(\"bM\", dist.Normal(0.0, 0.5))\n        M = bM * marriage\n    sigma = pyro.sample(\"sigma\", dist.Exponential(1.0))\n    mu = a + M + A\n    # pyro.sample(\"obs\", dist.Normal(mu, sigma), obs=divorce)\n    with pyro.plate(\"data\"):\n        pyro.sample(\"obs\", dist.Normal(mu, sigma), obs=divorce)\n\n\n\nWe first try to model the divorce rate as depending on a single variable, marriage rate. As mentioned above, we can use the same model code as earlier, but only pass values for marriage and divorce keyword arguments. We will use the No U-Turn Sampler (see [5] for more details on the NUTS algorithm) to run inference on this simple model.\nThe Hamiltonian Monte Carlo (or, the NUTS) implementation in Pyro takes in a potential energy function. This is the negative log joint density for the model. Therefore, for our model description above, we need to construct a function which given the parameter values returns the potential energy (or negative log joint density). Additionally, the verlet integrator in HMC (or, NUTS) returns sample values simulated using Hamiltonian dynamics in the unconstrained space. As such, continuous variables with bounded support need to be transformed into unconstrained space using bijective transforms. We also need to transform these samples back to their constrained support before returning these values to the user. Thankfully, this is handled on the backend for us, within a convenience class for doing MCMC inference that has the following methods:\n\nrun(...): runs warmup, adapts steps size and mass matrix, and does sampling using the sample from the warmup phase.\nsummary(): print diagnostic information like quantiles, effective sample size, and the Gelman-Rubin diagnostic.\nget_samples(): gets samples from the posterior distribution.\n\nNote:\n\nWe run inference with the NUTS sampler. To run vanilla HMC, we can instead use the HMC class.\n\n\n# Run NUTS\nkernel = NUTS(model)\nnum_samples = 2000 if not smoke_test else 2\nwarmup_steps=200 if not smoke_test else 2\nmcmc = MCMC(kernel, num_samples=num_samples, warmup_steps=warmup_steps)\n\n\nmcmc.run(\n    marriage=torch.tensor(dset.MarriageScaled.values, dtype=torch.float), \n    divorce=torch.tensor(dset.DivorceScaled.values, dtype=torch.float)\n)\nmcmc.summary()\nsamples_1 = mcmc.get_samples()\n\nSample: 100%|██████████| 2200/2200 [00:11, 195.90it/s, step size=8.56e-01, acc. prob=0.906]\n\n\n\n                mean       std    median      5.0%     95.0%     n_eff     r_hat\n         a      0.00      0.11      0.00     -0.17      0.19   2707.47      1.00\n        bM      0.35      0.12      0.35      0.14      0.55   1621.67      1.00\n     sigma      0.95      0.10      0.94      0.79      1.11   1390.63      1.00\n\nNumber of divergences: 0\n\n\n\n\n\n\n\nWe notice that the progress bar gives us online statistics on the acceptance probability, step size and number of steps taken per sample while running NUTS. In particular, during warmup, we adapt the step size and mass matrix to achieve a certain target acceptance probability which is 0.8, by default. We were able to successfully adapt our step size to achieve this target in the warmup phase.\nDuring warmup, the aim is to adapt hyper-parameters such as step size and mass matrix (the HMC algorithm is very sensitive to these hyper-parameters), and to reach the typical set (see [6] for more details). If there are any issues in the model specification, the first signal to notice would be low acceptance probabilities or very high number of steps. We use the sample from the end of the warmup phase to seed the MCMC chain (denoted by the second sample progress bar) from which we generate the desired number of samples from our target distribution.\nAt the end of inference, Pyro prints the mean, std and 90% CI values for each of the latent parameters. Note that since we standardized our predictors and response variable, we would expect the intercept to have mean 0, as can be seen here. It also prints other convergence diagnostics on the latent parameters in the model, effective sample size and the gelman rubin diagnostic (\\(\\hat{R}\\)). The value for these diagnostics indicates that the chain has converged to the target distribution. In our case, the “target distribution” is the posterior distribution over the latent parameters that we are interested in. Note that this is often worth verifying with multiple chains for more complicated models. In the end, samples_1 is a collection (in our case, a dict since init_samples was a dict) containing samples from the posterior distribution for each of the latent parameters in the model.\nTo look at our regression fit, let us plot the regression line using our posterior estimates for the regression parameters, along with the 90% Credibility Interval (CI). Note that the hpdi function in Pyro’s Statistical Utilities module can be used to compute CI. In the functions below, note that the collected samples from the posterior are all along the leading axis.\n\ndef plot_regression(x, y_mean, y_hpdi):\n    # Sort values for plotting by x axis\n    idx = np.argsort(x)\n    marriage = x[idx]\n    mean = y_mean[idx]\n    hpdi = y_hpdi[:, idx]\n    divorce = dset.DivorceScaled.values[idx]\n\n    # Plot\n    fig, ax = plt.subplots(nrows=1, ncols=1, figsize=(6, 6))\n    ax.plot(marriage, mean)\n    ax.plot(marriage, divorce, \"o\")\n    ax.fill_between(marriage, hpdi[0], hpdi[1], alpha=0.3, interpolate=True)\n    return ax\n\n# Compute empirical posterior distribution over mu\nposterior_mu = (\n    torch.unsqueeze(samples_1[\"a\"], -1)\n    + torch.unsqueeze(samples_1[\"bM\"], -1) * dset.MarriageScaled.values\n)\nmean_mu = torch.mean(posterior_mu, axis=0)\nhpdi_mu = stats.hpdi(posterior_mu, 0.9)\nax = plot_regression(dset.MarriageScaled.values, mean_mu, hpdi_mu)\nax.set(\n    xlabel=\"Marriage rate\", ylabel=\"Divorce rate\", title=\"Regression line with 90% CI\" \n);\n\n\n\n\nWe can see from the plot, that the CI broadens towards the tails where the data is relatively sparse, as can be expected.\n\n\n\nLet us check that we have set sensible priors by sampling from the prior predictive distribution. Pyro provides a handy Predictive utility for this purpose.\n\nfrom pyro.infer import Predictive\n\nprior_predictive = Predictive(model, num_samples=100)\nprior_predictions = prior_predictive(marriage=torch.tensor(dset.MarriageScaled.values, dtype=torch.float))[\n    \"obs\"\n]\nmean_prior_pred = torch.mean(prior_predictions, axis=0)\nhpdi_prior_pred = stats.hpdi(prior_predictions, 0.9)\n\nax = plot_regression(dset.MarriageScaled.values, mean_prior_pred, hpdi_prior_pred)\nax.set(xlabel=\"Marriage rate\", ylabel=\"Divorce rate\", title=\"Predictions with 90% CI\");\n\n\n\n\n\n\n\n\nLet us now look at the posterior predictive distribution to see how our predictive distribution looks with respect to the observed divorce rates. To get samples from the posterior predictive distribution, we need to run the model by substituting the latent parameters with samples from the posterior. Note that by default we generate a single prediction for each sample from the joint posterior distribution, but this can be controlled using the num_samples argument.\n\npredictive = Predictive(model=model, posterior_samples=samples_1)\npredictions = predictive(marriage=torch.tensor(dset.MarriageScaled.values, dtype=torch.float))[\"obs\"]\ndf = dset.filter([\"Location\"])\ndf[\"Mean Predictions\"] = torch.mean(predictions, axis=0)\ndf.head()\n\n\n\n\n\n  \n    \n      \n      Location\n      Mean Predictions\n    \n  \n  \n    \n      0\n      Alabama\n      0.024132\n    \n    \n      1\n      Alaska\n      0.511163\n    \n    \n      2\n      Arizona\n      0.040832\n    \n    \n      3\n      Arkansas\n      0.559602\n    \n    \n      4\n      California\n      -0.124215\n    \n  \n\n\n\n\n\n\nTo remove the magic behind Predictive, let us see how we can use Poutine (Effect Handlers). Unlike NumPyro, where we could combine the effect handlers with the vmap JAX primitive to implement our own simplified predictive utility function that can do vectorized predictions, here we use a native for-loop to show the same implementation.\n\ndef predict(post_samples, model, *args, **kwargs):\n    conditioned_model = poutine.condition(model, post_samples)\n    model_trace = poutine.trace(conditioned_model).get_trace(*args, **kwargs)\n    return model_trace.nodes[\"obs\"][\"value\"]\n\ndef predict_fn(post_samples):\n    with pyro.plate(\"samples\", num_samples):\n        return predict(post_samples, model, marriage=torch.reshape(torch.tensor(dset.MarriageScaled.values, \n                                            dtype=torch.float), (-1, 1)))\n\nNote the use of the condition and trace effect handlers in the predict function.\n\nThe condition effect handler conditions the latent sample sites to certain values. In our case, we are conditioning on values from the posterior distribution returned by MCMC.\nThe trace effect handler runs the model and records the execution trace within an OrderedDict. This trace object contains execution metadata that is useful for computing quantities such as the log joint density.\n\nIt should be clear now that the predict function simply runs the model by substituting the latent parameters with samples from the posterior (generated by the mcmc function) to generate predictions. Each draw from the posterior can be used to get predictions over all the 50 states. We get a predictions_1 array of shape (num_samples, 50). We can then compute the mean and 90% CI of these samples to plot the posterior predictive distribution. We note that our mean predictions are similar to those obtained from the Predictive utility class.\n\npredictions_1 = predict_fn(samples_1)\n\nmean_pred = torch.mean(predictions_1, axis=1)\ndf = dset.filter([\"Location\"])\ndf[\"Mean Predictions\"] = mean_pred\ndf.head()\n\n\n\n\n\n  \n    \n      \n      Location\n      Mean Predictions\n    \n  \n  \n    \n      0\n      Alabama\n      -0.003167\n    \n    \n      1\n      Alaska\n      0.497712\n    \n    \n      2\n      Arizona\n      -0.000853\n    \n    \n      3\n      Arkansas\n      0.572533\n    \n    \n      4\n      California\n      -0.075509\n    \n  \n\n\n\n\n\nhpdi_pred = stats.hpdi(predictions_1, 0.9)\nax = plot_regression(dset.MarriageScaled.values, mean_pred, hpdi_pred)\nax.set(xlabel=\"Marriage rate\", \n        ylabel=\"Divorce rate\", \n        title=\"Predictions with 90% CI\");\n\n\n\n\nWe have used the same plot_regression function as earlier. We notice that our CI for the predictive distribution is much broader as compared to the last plot due to the additional noise introduced by the sigma parameter. Most data points lie well within the 90% CI, which indicates a good fit.\n\n\n\nLikewise, making use of effect-handlers, we can also compute the log likelihood for this model given the dataset, and the log posterior predictive density [6] which is given by \\[ log \\prod_{i=1}^{n} \\int p(y_i | \\theta) p_{post}(\\theta) d\\theta\n\\approx \\sum_{i=1}^n log \\frac{\\sum_s p(\\theta^{s})}{S} \\\\\n= \\sum_{i=1}^n (log \\sum_s p(\\theta^{s}) - log(S))\n\\].\nHere, \\(i\\) indexes the observed data points \\(y\\) and \\(s\\) indexes the posterior samples over the latent parameters \\(\\theta\\). If the posterior predictive density for a model has a comparatively high value, it indicates that the observed data-points have higher probability under the given model.\n\ndef log_likelihood(params, model, *args, **kwargs):\n    model = poutine.condition(model, params)\n    model_trace = poutine.trace(model).get_trace(*args, **kwargs)\n    obs_node = model_trace.nodes[\"obs\"]\n    return obs_node[\"fn\"].log_prob(obs_node[\"value\"])\n\ndef log_pred_density_helper(params, model, n, var_not_used=None, *args, **kwargs):\n    single_param = {}\n    tmp_tensor = torch.empty(size=(num_samples, 50))\n    for i in range(n):\n        if var_not_used == 'age':\n            single_param = {\"a\": params[\"a\"][i], \"bM\": params[\"bM\"][i], \"sigma\": params[\"sigma\"][i]}\n        elif var_not_used == 'marriage':\n            single_param = {\"a\": params[\"a\"][i], \"bA\": params[\"bA\"][i], \"sigma\": params[\"sigma\"][i]}\n        else:\n            single_param = {\"a\": params[\"a\"][i], \"bM\": params[\"bM\"][i], \"bA\": params[\"bA\"][i], \"sigma\": params[\"sigma\"][i]}\n        tmp_tensor[i] = log_likelihood(single_param, model, *args, **kwargs)\n    return tmp_tensor\n\n\n\ndef log_pred_density(params, model, var_not_used=None, *args, **kwargs):\n    n = list(params.values())[0].shape[0]\n    log_lk_vals = log_pred_density_helper(params, model, n, var_not_used, *args, **kwargs)\n    return (torch.logsumexp(log_lk_vals, 0) - np.log(n)).sum()\n\n\nprint(\n    \"Log posterior predictive density: {}\".format(\n        log_pred_density(samples_1, \n                        model, \n                        var_not_used='age',\n                        marriage=torch.tensor(dset.MarriageScaled.values, dtype=torch.float),\n                        divorce=torch.tensor(dset.DivorceScaled.values, dtype=torch.float)\n                    )\n    )\n)\n\nLog posterior predictive density: -66.72371673583984\n\n\nIn this tutorial, we would like to emphasize that there is nothing magical about utility functions available in Pyro, and you can roll out your own inference utilities using Pyro’s effect handling stack.\n\n\n\nThe objective of variational inference is to pick a family of distributions with its own parameters to approximate the true posterior distribution. Then we find the parameter values which make the approximate distribution close the the true posterior. We carry out the steps below to define the model, extract the samples and plot the regression line. The only notable difference is that we define a guide to approximate the posterior. For this we use one of Pyro’s autoguides - AutoDiagonalNormal.\n\npyro.set_rng_seed(1)\n\nfrom pyro.infer import SVI, Trace_ELBO\nfrom pyro.infer.autoguide import AutoDiagonalNormal\n\nlearing_rate = 1e-4\n\nguide = AutoDiagonalNormal(model)\n\nnum_iter = 7000 if not smoke_test else 2\n\nsvi = SVI(\n    model,\n    guide,\n    optim.Adam({\"lr\": learing_rate}),\n    loss=Trace_ELBO()\n)\n\nloss = np.empty(num_iter)\n\npyro.clear_param_store()\nfor step in range(num_iter):\n    loss[step] = svi.step(\n        marriage=torch.tensor(dset.MarriageScaled.values, dtype=torch.float),\n        divorce=torch.tensor(dset.DivorceScaled.values, dtype=torch.float)\n    )\n    if step % 1000 == 0:\n        print(f'step: {step:>5}, ELBO loss: {loss[step]:.2f}')\n\nstep:     0, ELBO loss: 102.63\nstep:  1000, ELBO loss: 87.01\nstep:  2000, ELBO loss: 76.31\nstep:  3000, ELBO loss: 75.36\nstep:  4000, ELBO loss: 77.44\nstep:  5000, ELBO loss: 73.24\nstep:  6000, ELBO loss: 73.90\n\n\n\n# Plot the loss curve\nplt.plot(loss)\nplt.xlabel('step')\nplt.ylabel('ELBO Loss');\n\n\n\n\nWe sample from the posterior distribution of the regression parameters of the model using the Predictive utility.\n\nposterior_svi = Predictive(model, guide=guide, num_samples=num_samples)\nsamples_1_svi = {k: v.reshape(num_samples)\n                   for k, v in posterior_svi(\n                       marriage=torch.tensor(dset.MarriageScaled.values, dtype=torch.float),\n                       divorce=torch.tensor(dset.DivorceScaled.values, dtype=torch.float)\n                   ).items()\n                   if k != \"obs\"}\n\nLet us look at the regression fit of the SVI model. We plot the regression line using our posterior estimates for the regression parameters, along with the 90% Credibility Interval (CI). We can see that the regression fit is very similar to what we got for the NUTS model earlier.\n\n# Compute empirical posterior distribution over mu\nposterior_mu_svi = (\n    torch.unsqueeze(samples_1_svi[\"a\"], -1)\n    + torch.unsqueeze(samples_1_svi[\"bM\"], -1) * dset.MarriageScaled.values\n)\nmean_mu_svi = torch.mean(posterior_mu_svi, axis=0)\nhpdi_mu_svi = stats.hpdi(posterior_mu_svi, 0.9)\nax = plot_regression(dset.MarriageScaled.values, mean_mu_svi, hpdi_mu_svi)\nax.set(\n    xlabel=\"Marriage rate\", ylabel=\"Divorce rate\", title=\"Regression line with 90% CI\" \n);\n\n\n\n\n\n\n\n\nWe will now model the divorce rate as a function of the median age of marriage. The computations are mostly a reproduction of what we did for Model 1. Notice the following:\n\nDivorce rate is inversely related to the age of marriage. Hence states where the median age of marriage is low will likely have a higher divorce rate.\nWe get a higher log likelihood as compared to Model 2, indicating that median age of marriage is likely a much better predictor of divorce rate.\n\n\n# Run NUTS\nkernel = NUTS(model)\nnum_samples = 2000 if not smoke_test else 2\nwarmup_steps=200 if not smoke_test else 2\nmcmc = MCMC(kernel, num_samples=num_samples, warmup_steps=warmup_steps)\n\n\nmcmc.run(\n    age=torch.tensor(dset.AgeScaled.values, dtype=torch.float), \n    divorce=torch.tensor(dset.DivorceScaled.values, dtype=torch.float)\n)\nmcmc.summary()\nsamples_2 = mcmc.get_samples()\n\nSample: 100%|██████████| 2200/2200 [00:12, 175.14it/s, step size=7.52e-01, acc. prob=0.921]\n\n\n\n                mean       std    median      5.0%     95.0%     n_eff     r_hat\n         a     -0.00      0.10      0.00     -0.16      0.16   1865.24      1.00\n        bA     -0.57      0.11     -0.57     -0.76     -0.40   1618.48      1.00\n     sigma      0.82      0.09      0.82      0.67      0.95   1355.84      1.00\n\nNumber of divergences: 0\n\n\n\n\n\n\nposterior_mu = (\n    torch.unsqueeze(samples_2[\"a\"], -1)\n    + torch.unsqueeze(samples_2[\"bA\"], -1) * dset.AgeScaled.values\n)\nmean_mu = torch.mean(posterior_mu, axis=0)\nhpdi_mu = stats.hpdi(posterior_mu, 0.9)\nax = plot_regression(dset.AgeScaled.values, mean_mu, hpdi_mu)\nax.set(\n    xlabel=\"Median marriage age\", \n    ylabel=\"Divorce rate\", \n    title=\"Regression line with 90% CI\" \n);\n\n\n\n\n\npredictive_2 = Predictive(model, samples_2)\npredictions_2 = predictive_2(age=torch.tensor(dset.AgeScaled.values, dtype=torch.float))[\"obs\"]\n\nmean_pred = torch.mean(predictions_2, axis=0)\nhpdi_pred = stats.hpdi(predictions_2, 0.9)\n\nax = plot_regression(dset.AgeScaled.values, mean_pred, hpdi_pred)\nax.set(xlabel=\"Median Age\", ylabel=\"Divorce rate\", title=\"Predictions with 90% CI\");\n\n\n\n\n\nprint(\n    \"Log posterior predictive density: {}\".format(\n        log_pred_density(samples_2, \n                        model, \n                        var_not_used='marriage',\n                        age=torch.tensor(dset.AgeScaled.values, dtype=torch.float),\n                        divorce=torch.tensor(dset.DivorceScaled.values, dtype=torch.float)\n                    )\n    )\n)\n\nLog posterior predictive density: -59.240997314453125\n\n\n\n\n\nFinally, we will also model divorce rate as depending on both marriage rate as well as the median age of marriage. Note that the model’s posterior predictive density is similar to Model 2 which likely indicates that the marginal information from marriage rate in predicting divorce rate is low when the median age of marriage is already known.\n\n# Run NUTS\nkernel = NUTS(model)\nnum_samples = 2000 if not smoke_test else 2\nwarmup_steps=200 if not smoke_test else 2\nmcmc = MCMC(kernel, num_samples=num_samples, warmup_steps=warmup_steps)\n\n\nmcmc.run(\n    marriage=torch.tensor(dset.MarriageScaled.values, dtype=torch.float), \n    age=torch.tensor(dset.AgeScaled.values, dtype=torch.float), \n    divorce=torch.tensor(dset.DivorceScaled.values, dtype=torch.float)\n)\nmcmc.summary()\nsamples_3 = mcmc.get_samples()\n\nSample: 100%|██████████| 2200/2200 [00:17, 125.32it/s, step size=6.45e-01, acc. prob=0.906]\n\n\n\n                mean       std    median      5.0%     95.0%     n_eff     r_hat\n         a     -0.00      0.10     -0.00     -0.16      0.17   2052.14      1.00\n        bA     -0.60      0.15     -0.61     -0.84     -0.36   1583.09      1.00\n        bM     -0.06      0.15     -0.06     -0.29      0.21   1526.50      1.00\n     sigma      0.82      0.09      0.81      0.69      0.97   1719.60      1.00\n\nNumber of divergences: 0\n\n\n\n\n\n\nprint(\n    \"Log posterior predictive density: {}\".format(\n        log_pred_density(samples_3, \n                        model, \n                        # var_not_used='marriage',\n                        marriage=torch.tensor(dset.MarriageScaled.values, dtype=torch.float),\n                        age=torch.tensor(dset.AgeScaled.values, dtype=torch.float),\n                        divorce=torch.tensor(dset.DivorceScaled.values, dtype=torch.float)\n                    )\n    )\n)\n\nLog posterior predictive density: -59.04816436767578\n\n\n\n\n\nThe regression plots above shows that the observed divorce rates for many states differs considerably from the mean regression line. To dig deeper into how the last model (Model 3) under-predicts or over-predicts for each of the states, we will plot the posterior predictive and residuals (Observed divorce rate - Predicted divorce rate) for each of the states.\n\n# Predictions for Model 3\npredictive_3 = Predictive(model, samples_3)\npredictions_3 = predictive_3(marriage=dset.MarriageScaled.values, age=dset.AgeScaled.values)[\"obs\"]\n\n\ny = torch.arange(50)\n\nfig, ax = plt.subplots(nrows=1, ncols=2, figsize=(12, 16))\npred_mean = torch.mean(predictions_3, axis=0)\npred_hpdi = stats.hpdi(predictions_3, 0.9)\nresiduals_3 = torch.tensor(dset.DivorceScaled.values, dtype=torch.float) - predictions_3\nresiduals_mean = torch.mean(residuals_3, axis=0)\nresiduals_hpdi = stats.hpdi(residuals_3, 0.9)\nidx = torch.argsort(residuals_mean)\n\n# Plot posterior predictive\nax[0].plot(torch.zeros(50), y, \"--\")\nax[0].errorbar(\n    pred_mean[idx],\n    y,\n    xerr=pred_hpdi[1, idx] - pred_mean[idx],\n    marker=\"o\",\n    ms=5,\n    mew=4,\n    ls=\"none\",\n    alpha=0.8,\n)\nax[0].plot(dset.DivorceScaled.values[idx], y, marker=\"o\", ls=\"none\", color=\"gray\")\nax[0].set(\n    xlabel=\"Posterior Predictive (red) vs. Actuals (gray)\",\n    ylabel=\"State\",\n    title=\"Posterior Predictive with 90% CI\",\n)\nax[0].set_yticks(y)\nax[0].set_yticklabels(dset.Loc.values[idx], fontsize=10)\n\n# Plot residuals\nresiduals_3 = torch.tensor(dset.DivorceScaled.values, dtype=torch.float) - predictions_3\nresiduals_mean = torch.mean(residuals_3, axis=0)\nresiduals_hpdi = stats.hpdi(residuals_3, 0.9)\nerr = residuals_hpdi[1] - residuals_mean\n\nax[1].plot(torch.zeros(50), y, \"--\")\nax[1].errorbar(\n    residuals_mean[idx], y, xerr=err[idx], marker=\"o\", ms=5, mew=4, ls=\"none\", alpha=0.8\n)\nax[1].set(xlabel=\"Residuals\", ylabel=\"State\", title=\"Residuals with 90% CI\")\nax[1].set_yticks(y)\nax[1].set_yticklabels(dset.Loc.values[idx], fontsize=10);\n\n\n\n\nThe plot on the left shows the mean predictions with 90% CI for each of the states using Model 3. The gray markers indicate the actual observed divorce rates. The right plot shows the residuals for each of the states, and both these plots are sorted by the residuals, i.e. at the bottom, we are looking at states where the model predictions are higher than the observed rates, whereas at the top, the reverse is true.\nOverall, the model fit seems good because most observed data points like within a 90% CI around the mean predictions. However, notice how the model over-predicts by a large margin for states like Idaho (bottom left), and on the other end under-predicts for states like Maine (top right). This is likely indicative of other factors that we are missing out in our model that affect divorce rate across different states. Even ignoring other socio-political variables, one such factor that we have not yet modeled is the measurement noise given by Divorce SE in the dataset. We will explore this in the next section.\n\n\n\n\nNote that in our previous models, each data point influences the regression line equally. Is this well justified? We will build on the previous model to incorporate measurement error given by Divorce SE variable in the dataset. Incorporating measurement noise will be useful in ensuring that observations that have higher confidence (i.e. lower measurement noise) have a greater impact on the regression line. On the other hand, this will also help us better model outliers with high measurement errors. For more details on modeling errors due to measurement noise, refer to Chapter 14 of [1].\nTo do this, we will reuse Model 3, with the only change that the final observed value has a measurement error given by divorce_sd (notice that this has to be standardized since the divorce variable itself has been standardized to mean 0 and std 1).\n\ndef model_se(marriage, age, divorce_sd, divorce=None):\n    a = pyro.sample(\"a\", dist.Normal(0.0, 0.2))\n    bM = pyro.sample(\"bM\", dist.Normal(0.0, 0.5))\n    M = bM * marriage\n    bA = pyro.sample(\"bA\", dist.Normal(0.0, 0.5))\n    A = bA * age\n    sigma = pyro.sample(\"sigma\", dist.Exponential(1.0))\n    mu = a + M + A\n    divorce_rate = pyro.sample(\"divorce_rate\", dist.Normal(mu, sigma))\n    pyro.sample(\"obs\", dist.Normal(divorce_rate, divorce_sd), obs=divorce)\n\n\n# Standardize\ndset[\"DivorceScaledSD\"] = dset[\"Divorce SE\"] / np.std(dset.Divorce.values)\n\n\nnum_samples=3000 if not smoke_test else 2\nwarmup_steps=1000 if not smoke_test else 2\nkernel = NUTS(model_se, target_accept_prob=0.9)\nmcmc = MCMC(kernel, warmup_steps=warmup_steps, num_samples=num_samples)\nmcmc.run(\n    marriage=torch.tensor(dset.MarriageScaled.values, dtype=torch.float), \n    age=torch.tensor(dset.AgeScaled.values, dtype=torch.float), \n    divorce_sd=torch.tensor(dset.DivorceScaledSD, dtype=torch.float),\n    divorce=torch.tensor(dset.DivorceScaled.values, dtype=torch.float)\n)\nmcmc.summary()\nsamples_4 = mcmc.get_samples()\n\nSample: 100%|██████████| 4000/4000 [01:26, 46.32it/s, step size=2.66e-01, acc. prob=0.934]\n\n\n\n                      mean       std    median      5.0%     95.0%     n_eff     r_hat\n               a     -0.05      0.10     -0.05     -0.22      0.10   2892.05      1.00\n              bA     -0.61      0.16     -0.61     -0.87     -0.35   1764.01      1.00\n              bM      0.06      0.17      0.06     -0.22      0.32   1698.03      1.00\n divorce_rate[0]      1.15      0.37      1.14      0.52      1.73   4101.30      1.00\n divorce_rate[1]      0.68      0.54      0.66     -0.20      1.52   4700.64      1.00\n divorce_rate[2]      0.43      0.33      0.43     -0.09      1.00   5579.89      1.00\n divorce_rate[3]      1.41      0.45      1.40      0.64      2.15   4928.70      1.00\n divorce_rate[4]     -0.90      0.13     -0.90     -1.10     -0.68   5104.04      1.00\n divorce_rate[5]      0.65      0.40      0.64      0.01      1.33   4066.76      1.00\n divorce_rate[6]     -1.36      0.35     -1.35     -2.00     -0.83   5605.81      1.00\n divorce_rate[7]     -0.32      0.49     -0.31     -1.12      0.47   4610.33      1.00\n divorce_rate[8]     -1.88      0.60     -1.88     -2.85     -0.92   2866.64      1.00\n divorce_rate[9]     -0.62      0.17     -0.62     -0.89     -0.34   5923.41      1.00\ndivorce_rate[10]      0.75      0.29      0.75      0.28      1.23   4697.33      1.00\ndivorce_rate[11]     -0.53      0.48     -0.53     -1.39      0.22   3437.37      1.00\ndivorce_rate[12]      0.21      0.49      0.22     -0.57      1.03   2057.42      1.00\ndivorce_rate[13]     -0.86      0.23     -0.86     -1.27     -0.53   7300.48      1.00\ndivorce_rate[14]      0.55      0.31      0.55      0.01      1.04   4580.96      1.00\ndivorce_rate[15]      0.28      0.38      0.29     -0.41      0.86   6245.29      1.00\ndivorce_rate[16]      0.50      0.43      0.50     -0.20      1.20   5173.23      1.00\ndivorce_rate[17]      1.24      0.35      1.23      0.72      1.85   3672.41      1.00\ndivorce_rate[18]      0.42      0.38      0.41     -0.18      1.06   5871.63      1.00\ndivorce_rate[19]      0.38      0.53      0.37     -0.48      1.24   2655.37      1.00\ndivorce_rate[20]     -0.56      0.31     -0.56     -1.05     -0.03   4313.36      1.00\ndivorce_rate[21]     -1.10      0.27     -1.10     -1.51     -0.64   4575.67      1.00\ndivorce_rate[22]     -0.27      0.26     -0.27     -0.70      0.15   5345.20      1.00\ndivorce_rate[23]     -1.00      0.30     -1.00     -1.47     -0.50   4594.95      1.00\ndivorce_rate[24]      0.42      0.41      0.40     -0.24      1.08   4888.42      1.00\ndivorce_rate[25]     -0.03      0.30     -0.02     -0.52      0.47   5341.36      1.00\ndivorce_rate[26]     -0.03      0.50     -0.03     -0.78      0.84   4283.69      1.00\ndivorce_rate[27]     -0.15      0.39     -0.14     -0.78      0.49   4833.08      1.00\ndivorce_rate[28]     -0.27      0.49     -0.27     -1.08      0.54   3475.12      1.00\ndivorce_rate[29]     -1.79      0.23     -1.79     -2.17     -1.41   5616.94      1.00\ndivorce_rate[30]      0.18      0.42      0.17     -0.53      0.85   5533.95      1.00\ndivorce_rate[31]     -1.66      0.17     -1.66     -1.94     -1.39   5818.72      1.00\ndivorce_rate[32]      0.12      0.24      0.12     -0.28      0.51   5921.18      1.00\ndivorce_rate[33]     -0.03      0.50     -0.00     -0.82      0.84   3123.85      1.00\ndivorce_rate[34]     -0.12      0.22     -0.12     -0.49      0.22   4427.76      1.00\ndivorce_rate[35]      1.26      0.40      1.25      0.61      1.90   4695.57      1.00\ndivorce_rate[36]      0.22      0.35      0.22     -0.34      0.82   5018.34      1.00\ndivorce_rate[37]     -1.03      0.22     -1.03     -1.36     -0.66   4955.84      1.00\ndivorce_rate[38]     -0.93      0.54     -0.95     -1.91     -0.12   3953.88      1.00\ndivorce_rate[39]     -0.68      0.32     -0.67     -1.23     -0.18   6472.10      1.00\ndivorce_rate[40]      0.24      0.54      0.24     -0.59      1.20   4899.75      1.00\ndivorce_rate[41]      0.74      0.34      0.73      0.17      1.30   3620.41      1.00\ndivorce_rate[42]      0.20      0.18      0.19     -0.10      0.51   6072.49      1.00\ndivorce_rate[43]      0.82      0.43      0.82      0.13      1.54   3248.31      1.00\ndivorce_rate[44]     -0.42      0.53     -0.41     -1.27      0.44   4783.05      1.00\ndivorce_rate[45]     -0.39      0.26     -0.39     -0.87     -0.01   6733.07      1.00\ndivorce_rate[46]      0.13      0.29      0.13     -0.37      0.58   6125.59      1.00\ndivorce_rate[47]      0.56      0.46      0.55     -0.15      1.32   5691.95      1.00\ndivorce_rate[48]     -0.63      0.28     -0.63     -1.11     -0.21   4968.47      1.00\ndivorce_rate[49]      0.87      0.57      0.88     -0.09      1.78   2810.28      1.00\n           sigma      0.58      0.11      0.57      0.38      0.73   1217.76      1.00\n\nNumber of divergences: 0\n\n\n\n\nNotice that our values for the regression coefficients is very similar to Model 3. However, introducing measurement noise allows us to more closely match our predictive distribution to the observed values. We can see this if we plot the residuals as earlier.\n\n# Predictions for Model SE\npredictive_4 = Predictive(model_se, samples_4)\npredictions_4 = predictive_4(\n    marriage=torch.tensor(dset.MarriageScaled.values, dtype=torch.float), \n    age=torch.tensor(dset.AgeScaled.values, dtype=torch.float),\n    divorce_sd=torch.tensor(dset.DivorceScaledSD.values, dtype=torch.float),\n    )[\"obs\"]\n\n\nsd = torch.tensor(dset.DivorceScaledSD.values, dtype=torch.float)\nresiduals_4 = torch.tensor(dset.DivorceScaled.values, dtype=torch.float) - predictions_4\nresiduals_mean = torch.mean(residuals_4, axis=0)\nresiduals_hpdi = stats.hpdi(residuals_4, 0.9)\nerr = residuals_hpdi[1] - residuals_mean\nidx = torch.argsort(residuals_mean)\ny = torch.arange(50)\nfig, ax = plt.subplots(nrows=1, ncols=1, figsize=(6, 16))\n\n\n# Plot Residuals\nax.plot(torch.zeros(50), y, \"--\")\nax.errorbar(\n    residuals_mean[idx], y, xerr=err[idx], marker=\"o\", ms=5, mew=4, ls=\"none\", alpha=0.8\n)\n\n# Plot SD\nax.errorbar(residuals_mean[idx], y, xerr=sd[idx], ls=\"none\", color=\"orange\", alpha=0.9)\n\n# Plot earlier mean residual\nax.plot(\n    torch.mean(torch.tensor(dset.DivorceScaled.values, dtype=torch.float) - predictions_3, 0)[idx],\n    y,\n    ls=\"none\",\n    marker=\"o\",\n    ms=6,\n    color=\"black\",\n    alpha=0.6,\n)\n\nax.set(xlabel=\"Residuals\", ylabel=\"State\", title=\"Residuals with 90% CI\")\nax.set_yticks(y)\nax.set_yticklabels(dset.Loc.values[idx], fontsize=10)\nax.text(\n    -2.8,\n    -7,\n    \"Residuals (with error-bars) from current model (in red). \"\n    \"Black marker \\nshows residuals from the previous model (Model 3). \"\n    \"Measurement \\nerror is indicated by orange bar.\",\n);\n\n\n\n\nThe plot above shows the residuals for each of the states, along with the measurement noise given by inner error bar. The gray dots are the mean residuals from our earlier Model 3. Notice how having an additional degree of freedom to model the measurement noise has shrunk the residuals. In particular, for Idaho and Maine, our predictions are now much closer to the observed values after incorporating measurement noise in the model.\nTo better see how measurement noise affects the movement of the regression line, let us plot the residuals with respect to the measurement noise.\n\nfig, ax = plt.subplots(nrows=1, ncols=1, figsize=(10, 6))\nx = torch.tensor(dset.DivorceScaledSD.values, dtype=torch.float)\ny1 = torch.mean(residuals_3, 0)\ny2 = torch.mean(residuals_4, 0)\nax.plot(x, y1, ls=\"none\", marker=\"o\")\nax.plot(x, y2, ls=\"none\", marker=\"o\")\nfor i, (j, k) in enumerate(zip(y1, y2)):\n    ax.plot([x[i], x[i]], [j, k], \"--\", color=\"gray\")\n\nax.set(\n    xlabel=\"Measurement Noise\",\n    ylabel=\"Residual\",\n    title=\"Mean residuals (Model 4: red, Model 3: blue)\",\n);\n\n\n\n\nThe plot above shows what has happened in more detail - the regression line itself has moved to ensure a better fit for observations with low measurement noise (left of the plot) where the residuals have shrunk very close to 0. That is to say that data points with low measurement error have a concomitantly higher contribution in determining the regression line. On the other hand, for states with high measurement error (right of the plot), incorporating measurement noise allows us to move our posterior distribution mass closer to the observations resulting in a shrinkage of residuals as well.\n\n\n\n\n\nMcElreath, R. (2016). Statistical Rethinking: A Bayesian Course with Examples in R and Stan CRC Press.\nStan Development Team. Stan User’s Guide\nGoodman, N.D., and StuhlMueller, A. (2014). The Design and Implementation of Probabilistic Programming Languages\nPyro Development Team. Poutine: A Guide to Programming with Effect Handlers in Pyro\nHoffman, M.D., Gelman, A. (2011). The No-U-Turn Sampler: Adaptively Setting Path Lengths in Hamiltonian Monte Carlo.\nBetancourt, M. (2017). A Conceptual Introduction to Hamiltonian Monte Carlo.\nJAX Development Team (2018). Composable transformations of Python+NumPy programs: differentiate, vectorize, JIT to GPU/TPU, and more\nGelman, A., Hwang, J., and Vehtari A. Understanding predictive information criteria for Bayesian models"
  },
  {
    "objectID": "posts/multicollinearity/multicollinearity_index.html",
    "href": "posts/multicollinearity/multicollinearity_index.html",
    "title": "The effect of multicollinearity on inference and prediction",
    "section": "",
    "text": "In this post, I will simulate a data set where there is multicollinearity, i.e. when independent variables are correlated. We will see the effect of multicollinearity on the estimates of the sample coefficients of the independent variables. In particular, we will see the spread of the estimates of the sample coefficients as we repeatedly draw samples from the main dataset. For the purpose of this experiment, I will assume that this main data set represents the population and the weights assigned in creating this population dataset represent the population coefficients/parameters that we are trying to estimate from the samples drawn from the population.\n\nFurther, to provide a contrast, I will then simulate a data set where the independent variables are not as correlated and check the spread estimates of the coefficients of the independent variables.\n\nNote: Independent variables and features are synonymous and the two terms are used interchangeably.\n\nimport numpy as np\nimport pandas as pd\nfrom sklearn.linear_model import LinearRegression\nfrom statsmodels.stats.outliers_influence import variance_inflation_factor\nimport altair as alt\nimport matplotlib.pyplot as plt\n\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import mean_absolute_percentage_error\n\n\n\nNow let us explore the effect of multicollinearity on inference, particularly on estimation of the coefficients of the indepedent variables.\n\n\n\nI will create a data set of 10,000 observations (rows) and five independent variables. From these independent variables or features, the target variable is defined as a linear combination of the independent variables and some random error (or noise).\n\ndef make_dataset(n_samples, n_features, corr_matrix, weights, seed=123):\n  \n  np.random.seed(seed)\n\n  n_samples = n_samples #10_000\n  n_features = n_features #5\n  corr = corr_matrix\n\n  # Use the correlation matrix to create a covariance matrix\n  cov = np.dot(np.transpose(corr), corr)\n\n  # Generate a random sample from the multivariate normal distribution with the specified covariance matrix\n  X = np.random.multivariate_normal(mean=np.zeros(n_features), cov=cov, size=n_samples)\n\n  # Add a target variable to the dataset\n  target_variable = np.dot(X, weights) + np.random.normal(size=n_samples)\n  data = pd.DataFrame(data=np.column_stack((X, target_variable)), columns=['feature_1', 'feature_2', 'feature_3', 'feature_4', 'feature_5', 'target_variable'])\n\n  return data\n\n\ncorr_matrix = np.array([[1, 0.8, 0.6, 0.4, 0.2],\n                 [0.8, 1, 0.4, 0.3, 0.1],\n                 [0.6, 0.4, 1, 0.2, 0.3],\n                 [0.4, 0.3, 0.2, 1, 0.7],\n                 [0.2, 0.1, 0.3, 0.7, 1]])\n\nweights=[2.0, 3.0, 4.0, 5.0, 6.0]\n\ndata = make_dataset(n_samples=10_000, n_features=5, corr_matrix=corr_matrix, weights=weights)\n\n\ndata.head()\n\n\n\n  \n    \n      \n\n\n  \n    \n      \n      feature_1\n      feature_2\n      feature_3\n      feature_4\n      feature_5\n      target_variable\n    \n  \n  \n    \n      0\n      1.264021\n      0.689230\n      0.848691\n      2.144810\n      1.622949\n      30.397354\n    \n    \n      1\n      -1.291609\n      -0.802827\n      -1.093697\n      -3.810501\n      -3.329843\n      -47.990066\n    \n    \n      2\n      1.206737\n      1.222757\n      -0.016694\n      1.099470\n      0.293953\n      15.380844\n    \n    \n      3\n      -0.249371\n      0.160813\n      -1.296871\n      2.350512\n      2.139925\n      20.192366\n    \n    \n      4\n      -1.697340\n      -1.914215\n      -0.811186\n      -0.239564\n      0.901467\n      -9.486861\n    \n  \n\n\n      \n        \n  \n    \n    \n  \n      \n      \n  \n\n      \n    \n  \n  \n\n\n\n\n\nLet us check for multicollinearity by either of the below mentioned methods: - Variation Inflation Factor (VIF) identifies correlation between the independent variables and the stregth of that correlation - Correlation Matrix shows the correlation coefficients of several variables in a tabular format\n\nX = data.drop(['target_variable'], axis=1)\nvif = pd.DataFrame()\nvif[\"VIF Factor\"] = [variance_inflation_factor(X.values, i) for i in range(X.shape[1])]\nvif[\"features\"] = X.columns\nprint(vif)\n\n   VIF Factor   features\n0   60.906229  feature_1\n1   27.990330  feature_2\n2   11.165629  feature_3\n3   19.447858  feature_4\n4   15.368583  feature_5\n\n\n\ncorr_matrix = X.corr().abs()\ncorr_matrix\n\n\n\n  \n    \n      \n\n\n  \n    \n      \n      feature_1\n      feature_2\n      feature_3\n      feature_4\n      feature_5\n    \n  \n  \n    \n      feature_1\n      1.000000\n      0.968190\n      0.869677\n      0.651794\n      0.490790\n    \n    \n      feature_2\n      0.968190\n      1.000000\n      0.770480\n      0.576742\n      0.385647\n    \n    \n      feature_3\n      0.869677\n      0.770480\n      1.000000\n      0.558766\n      0.543132\n    \n    \n      feature_4\n      0.651794\n      0.576742\n      0.558766\n      1.000000\n      0.921675\n    \n    \n      feature_5\n      0.490790\n      0.385647\n      0.543132\n      0.921675\n      1.000000\n    \n  \n\n\n      \n        \n  \n    \n    \n  \n      \n      \n  \n\n      \n    \n  \n  \n\n\nNow let us define a function, which will sample with replacement for a defined number of iterations and return the estimates of the coefficients of the independent variables from the drawn samples from each iteration.\n\ndef sample_and_regress(df, features, target, n_iterations):\n    coef_list = []\n    for i in range(n_iterations):\n        # randomly sample from dataframe\n        sample_df = df.sample(frac=0.1, replace=True)\n        # fit linear regression model\n        model = LinearRegression().fit(sample_df[features], sample_df[target])\n        # save feature coefficients\n        coef_list.append(model.coef_)\n    # create dataframe of feature coefficients\n    coef_df = pd.DataFrame(coef_list, columns=features)\n    # return dataframe\n    return coef_df\n\n\nnp.random.seed(123)\n\nfeatures = ['feature_1', 'feature_2', 'feature_3', 'feature_4', 'feature_5']\ntarget = 'target_variable'\nn_iterations = 1000\ncoef_df = sample_and_regress(data, features, target, n_iterations)\n\n\n# create list of charts, one for each feature\ncoef_dist_list = []\nfor feature in features:\n    coef_df_feature = coef_df[[feature]].reset_index().melt(id_vars='index', value_name='Coefficient')\n    coef_dist = alt.Chart(coef_df_feature).mark_area(opacity=0.5).encode(\n        x=alt.X('Coefficient:Q', bin=alt.Bin(maxbins=50)),\n        y=alt.Y('count()', stack=None),\n    ).properties(\n        title=f'{feature} Coefficient Distribution',\n        width=200,\n        height=200\n    )\n    \n    # calculate percentiles\n    percentiles = np.percentile(coef_df[feature], [2.5, 50, 97.5])\n    \n    # add vertical lines to chart\n    coef_dist = coef_dist + alt.Chart(pd.DataFrame({'Percentile': percentiles})).mark_rule(color='red').encode(\n        x='Percentile:Q'\n    )\n    \n    # add text labels for mean and percentiles\n    mean_label = alt.Chart(pd.DataFrame({'mean': [coef_df[feature].mean()]})).mark_text(dx=15, dy=-15, align='left', baseline='middle').encode(\n        x='mean:Q',\n        text=alt.Text('mean:Q', format='.2f')\n    )\n    \n    p2_5_label = alt.Chart(pd.DataFrame({'p2_5': [percentiles[0]]})).mark_text(dx=15, dy=-30, align='left', baseline='middle').encode(\n        x='p2_5:Q',\n        text=alt.Text('p2_5:Q', format='.2f')\n    )\n    \n    p97_5_label = alt.Chart(pd.DataFrame({'p97_5': [percentiles[2]]})).mark_text(dx=15, dy=30, align='left', baseline='middle').encode(\n        x='p97_5:Q',\n        text=alt.Text('p97_5:Q', format='.2f')\n    )\n    \n    coef_dist = coef_dist + mean_label + p2_5_label + p97_5_label\n    \n    coef_dist_list.append(coef_dist)\n\n# combine the charts using altair.hconcat\ncoef_dist_combined = alt.hconcat(*coef_dist_list)\n\ncoef_dist_combined\n\n\n\n\n\n\n\n\n\n\ncorr_matrix_less_col = np.array([[1, 0.5, 0.5, 0.4, 0.2],\n                              [0.5, 1, 0.4, 0.3, 0.1],\n                              [0.5, 0.4, 1, 0.2, 0.3],\n                              [0.4, 0.3, 0.2, 1, 0.5],\n                              [0.2, 0.1, 0.3, 0.5, 1]])\n\nweights=[2.0, 3.0, 4.0, 5.0, 6.0]\n\ndata_less_col = make_dataset(n_samples=10_000, n_features=5, corr_matrix=corr_matrix_less_col, weights=weights)\n\n\nX_less_col = data_less_col.drop(['target_variable'], axis=1)\nvif_less_col = pd.DataFrame()\nvif_less_col[\"VIF Factor\"] = [variance_inflation_factor(X_less_col.values, i) for i in range(X_less_col.shape[1])]\nvif_less_col[\"features\"] = X_less_col.columns\nprint(vif_less_col)\n\n   VIF Factor   features\n0    6.321622  feature_1\n1    3.834628  feature_2\n2    4.608889  feature_3\n3    5.430892  feature_4\n4    4.182388  feature_5\n\n\n\nnp.random.seed(123)\n\nfeatures = ['feature_1', 'feature_2', 'feature_3', 'feature_4', 'feature_5']\ntarget = 'target_variable'\nn_iterations = 1000\ncoef_df = sample_and_regress(data_less_col, features, target, n_iterations)\n\n\n# create list of charts, one for each feature\ncoef_dist_list = []\nfor feature in features:\n    coef_df_feature = coef_df[[feature]].reset_index().melt(id_vars='index', value_name='Coefficient')\n    coef_dist = alt.Chart(coef_df_feature).mark_area(opacity=0.5).encode(\n        x=alt.X('Coefficient:Q', bin=alt.Bin(maxbins=50)),\n        y=alt.Y('count()', stack=None),\n    ).properties(\n        title=f'{feature} Coefficient Distribution',\n        width=200,\n        height=200\n    )\n    \n    # calculate percentiles\n    percentiles = np.percentile(coef_df[feature], [2.5, 50, 97.5])\n    \n    # add vertical lines to chart\n    coef_dist = coef_dist + alt.Chart(pd.DataFrame({'Percentile': percentiles})).mark_rule(color='red').encode(\n        x='Percentile:Q'\n    )\n    \n    # add text labels for mean and percentiles\n    mean_label = alt.Chart(pd.DataFrame({'mean': [coef_df[feature].mean()]})).mark_text(dx=15, dy=-15, align='left', baseline='middle').encode(\n        x='mean:Q',\n        text=alt.Text('mean:Q', format='.2f')\n    )\n    \n    p2_5_label = alt.Chart(pd.DataFrame({'p2_5': [percentiles[0]]})).mark_text(dx=15, dy=-30, align='left', baseline='middle').encode(\n        x='p2_5:Q',\n        text=alt.Text('p2_5:Q', format='.2f')\n    )\n    \n    p97_5_label = alt.Chart(pd.DataFrame({'p97_5': [percentiles[2]]})).mark_text(dx=15, dy=30, align='left', baseline='middle').encode(\n        x='p97_5:Q',\n        text=alt.Text('p97_5:Q', format='.2f')\n    )\n    \n    coef_dist = coef_dist + mean_label + p2_5_label + p97_5_label\n    \n    coef_dist_list.append(coef_dist)\n\n# combine the charts using altair.hconcat\ncoef_dist_combined = alt.hconcat(*coef_dist_list)\n\ncoef_dist_combined\n\n\n\n\n\n\n\n\nThe 95% confidence intervals for the estimates are less spread out for the data set where the independent variables are less correlates in comparison to the case where we have determined there is multicollinearity.\nHence, we can see that the presence of multicollinearity reduces the precision of the estimates of the coefficients, which weakens the statistical power of the model.\nFor more on this, please check the blog post linked in References.\n\n\n\n\n\nNow let us explore the effect of multicollinearity on predictions.\nI will consider MAPE as the measure of the quality of the predictions generated by our model.\nNow let us define a function, which will sample with replacement for a defined number of iterations, split the sample into train and test data sets, fit a linear regression model on the train set and, finally, evaluate the model performance in terms of the MAPE of the test data set. The MAPE values for each of the iterations is returned by the function.\n\ndef evaluate_mape(df, features, target, iterations):\n    mape_list = []\n    for i in range(iterations):\n        # Sample 10% of the dataframe\n        sample_df = df.sample(frac=0.1, random_state=i)\n        # Split data into train and test sets\n        X_train, X_test, y_train, y_test = train_test_split(sample_df[features], sample_df[target], test_size=0.2, random_state=i)\n        # Fit linear regression model on train set\n        model = LinearRegression().fit(X_train, y_train)\n        # Predict target variable on test set\n        y_pred = model.predict(X_test)\n        # Evaluate MAPE on test set\n        mape = mean_absolute_percentage_error(y_test, y_pred)\n        mape_list.append(mape)\n    # Return MAPE for each iteration as a dataframe\n    return pd.DataFrame(mape_list, columns=['MAPE'])\n\n\nnp.random.seed(123)\n\nmape_df = evaluate_mape(data, ['feature_1', 'feature_2', 'feature_3', 'feature_4', 'feature_5'], 'target_variable', 1_000)\n\n\nprint(f\"Mean MAPE = {mape_df['MAPE'].mean():.5f}\")\nprint(f\"Std dev of MAPE = {mape_df['MAPE'].std():.5f}\")\n\nMean MAPE = 0.25335\nStd dev of MAPE = 0.21339\n\n\n\n\nOne possible fix to address multicollinearity is to remove some of the highly correlated features. In this case, let us remove feature_1, which has the highest VIF score, and then evaluating the mean MAPE as above.\n\nnp.random.seed(123)\n\nmape_df = evaluate_mape(data, ['feature_2', 'feature_3', 'feature_4', 'feature_5'], 'target_variable', 1_000)\nprint(f\"Mean MAPE = {mape_df['MAPE'].mean():.5f}\")\nprint(f\"Std dev of MAPE = {mape_df['MAPE'].std():.5f}\")\n\nMean MAPE = 0.26089\nStd dev of MAPE = 0.17457\n\n\n\n\n\nMulticollinearity, in general, does not influence the predictions. I decided to conduct this small experiement so that I could visualize the effect of multicollinearity during inference and then evaluate the effect on predictions. In the past, I have probably negatively impacted my performance during a few interviews by stating that moderate correlation among the features does not inhibit the quality of predictions. In case you are looking for an academic reference stating the same, you can find the reference in the blog post linked in References.\n\n\n\n\nMulticollinearity in Regression Analysis: Problems, Detection, and Solutions"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Arijeet Chatterjee",
    "section": "",
    "text": "I am currently working on data science and machine learning projects in retail."
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "Blog",
    "section": "",
    "text": "The effect of multicollinearity on inference and prediction\n\n\n\n\n\n\n\nMulticollinearity\n\n\nRegression\n\n\n\n\nVisualize the effect of multicollinearity when doing inference and on quality of the predictions\n\n\n\n\n\n\nApr 16, 2023\n\n\n\n\n\n\n\n\nBayesian Regression Using Pyro\n\n\n\n\n\n\n\nBayesian Regression\n\n\nPyro\n\n\n\n\nAn example of Bayesian regression adapted from a NumPyro tutorial. In this tutorial I use Pyro. This tutorial was developed as an open source contribution for Pyro.\n\n\n\n\n\n\nApr 8, 2023\n\n\n\n\n\n\nNo matching items"
  }
]